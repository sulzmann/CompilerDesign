<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Martin Sulzmann" />
  <title>Mini-Go Language Description</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Mini-Go Language Description</h1>
  <p class="author">
Martin Sulzmann
  </p>
</div>
<div id="examples" class="slide section level1">
<h1>Examples</h1>
<p>Here are some sample programs.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">{
  x := <span class="dv">1</span>;
  y := <span class="ot">true</span>;
  ch := newChannel;

  <span class="kw">go</span> {  while y {
           ch &lt;- <span class="dv">1</span>
        }
     };

  while y {
    &lt;-ch
  };
 x = x + <span class="dv">1</span>
}</code></pre></div>
<p>Like Go we support message-passing via channels. However, the transmitted values are restricted to be integers. A channel of integers is introduced via `newChannel'.</p>
<p>Basic channel operations are as follows. For transmission we write <code>ch &lt;- 1</code> to send value <code>1</code> via channel <code>ch</code>. To receive a value over channel <code>ch</code> we write <code>&lt;-ch</code>. If <code>&lt;-ch</code> appears as a statement, the received value is ignored but we can also store a value via <code>z := &lt;-ch</code>.</p>
<p>Via <code>x := 1</code> we declare a new variable where the type of <code>x</code> is defined by the right-hand side. If we want to overwrite the value of an existing variable, we write <code>x = x + 1</code>.</p>
<p>Mini-Go supports nested <em>code blocks</em> where a variable can be re-declared in some inner block. More on this later.</p>
<p>Mini-Go also supports (recursive) functions. For example, consider the following recursive definition of the factorial function.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> fac(x <span class="dt">int</span>) <span class="dt">int</span> {
   <span class="kw">if</span> x &lt;= <span class="dv">1</span> {
      <span class="kw">return</span> <span class="dv">1</span>
   } <span class="kw">else</span> {
      <span class="kw">return</span> x * fac(x<span class="dv">-1</span>)
   }      
}

{
  x := fac(<span class="dv">4</span>);
  <span class="fu">print</span> x
}</code></pre></div>
<p>As we can see, the <code>main</code> function is implicit and corresponds to the code block following all function definitions (if any).</p>
<p>Function definitions must carry explicit type declarations for formal parameters and return arguments. Like in Go, we write <code>x int</code> to introduce a formal parameter <code>x</code> of type <code>int</code>. The return type follows after, here <code>int</code>. So, the order is switched compared to function declarations in languages such as C and Java.</p>
</div>
<div id="syntax" class="slide section level1">
<h1>Syntax</h1>
<p>Here comes the formal syntax description of Mini-Go.</p>
<pre><code>We roughly follow the EBNF style grammar notation

http://en.wikipedia.org/wiki/Extended_Backusâ€“Naur_Form

{ ... } stands for repetition

[ ... ] stands for option


operator precedence from top (highest) to bottom (lowest)

* /
+ -
&gt;
==
&amp;&amp;
||   -- not supported

prog      ::= { proc } block
proc      ::= &quot;func&quot; name &quot;(&quot; [param] &quot;)&quot; [type] block
param     ::= { vars type &quot;,&quot; } vars type
block     ::= &quot;{&quot; statement &quot;}&quot;
statement ::= statement &quot;;&quot; statement
            |  &quot;go&quot; block
            |  vars &quot;&lt;-&quot; aexp
            |  &quot;&lt;-&quot; vars
            |  vars &quot;:=&quot; bexp
            |  vars &quot;:=&quot; &quot;newChannel&quot;
            |  vars &quot;=&quot;  bexp
            |  &quot;while&quot; bexp block
            |  &quot;if&quot; bexp block &quot;else&quot; block
            |  &quot;return&quot; bexp
            |  name &quot;(&quot; arg &quot;)&quot;
            |  &quot;print&quot; bexp


bexp ::= cexp { &quot;&amp;&amp;&quot; cexp }

cexp ::= cterm [ &quot;==&quot; cterm ]

cterm ::= aexp [ &quot;&gt;&quot; aexp ]

aexp ::= term { &quot;+&quot; term | &quot;-&quot; term }

term ::= factor { &quot;*&quot; factor | &quot;/&quot; factor }

factor ::=  ints | bools | vars | &quot;&lt;-&quot; vars | &quot;!&quot; factor | &quot;(&quot; bexp &quot;)&quot; | name &quot;(&quot; arg &quot;)&quot;

arg ::= {bexp &quot;,&quot;} bexp

digit ::= &#39;0&#39; | ... | &#39;9&#39;

ints ::=  digit { digit }

bools ::= &#39;true&#39; | &#39;false&#39;

letter ::= &#39;a&#39; | ... | &#39;z&#39;

vars ::=  letter { digit | letter }

name ::= letter { letter }

type ::= &quot;int&quot; | &quot;bool&quot; | &quot;chan int&quot;
</code></pre>
<p>Points to note:</p>
<ul>
<li>The last (final) statement does not carry a trailing semicolon <code>;</code></li>
</ul>
</div>
<div id="static-semantics" class="slide section level1">
<h1>Static Semantics</h1>
<p>Describe the proper <em>static</em> behavior of Mini-Go programs (i.e. without actually running the program).</p>
<p>Things to take care of:</p>
<ul>
<li><p>Proper use of values and functions</p></li>
<li><p>Proper variable declarations</p></li>
</ul>
<p>Let us consider a few examples.</p>
<h2 id="incorrect-syntax">Incorrect syntax</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">{
  x := newChannel;
  z := &lt;-y;      
}</code></pre></div>
<p>There's no <code>;</code> in case of a final/single statement. Hence, the above program is not syntactically correct.</p>
<p>To specify the proper static behavior of Mini-Go programs, we assume that programs are syntactically correct.</p>
<h2 id="undeclared-variable">Undeclared variable</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">{
  x := newChannel;
  z := &lt;-y
}</code></pre></div>
<p>Syntactically correct program. Still the program seems wrong as variable <code>y</code> is not declared. We wish that this 'wrong' behavior is caught by the static semantics.</p>
<h2 id="no-redeclarations">No redeclarations</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">{
  x := newChannel;
  z := &lt;-x;
  z := <span class="dv">1</span>
}</code></pre></div>
<p>Syntactically correct program. The problem from above is fixed. There is a new problem. We shall not redeclare the same variable, here <code>z</code>. Yet again we wish that the static semantics detects that the above program is 'improper'.</p>
<h2 id="incompatible-types">Incompatible types</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">{
  x := newChannel;
  z := &lt;-x;
  z = z &amp;&amp; <span class="ot">true</span>
}</code></pre></div>
<p>Syntactically correct program. All variables properly declared. The problem here is that variable <code>z</code> is declared as a Boolean variable but used in a context where <code>z</code> is assumed to be an Integer. This is clearly wrong.</p>
<h2 id="limits-of-static-checks">Limits of Static Checks</h2>
<p>The above are all 'improper' cases which shall be detected by the static semantics. There are many other cases of 'illegal' behavior which are not covered by the static semantics (e.g. division by zero, deadlocks etc). The reason for not covering such cases is that we wish to keep the static semantics checks <em>simple</em> and <em>decidable</em>.</p>
<h2 id="type-checking-rules">Type Checking Rules</h2>
<p>We enforce the proper static semantics via typing rules. We assign types to Mini-Go program parts and by specifying (typing) rules for the various syntactic constructs of Mini-Go we guarantee that the above (informally) specified static semantic rules are obeyed.</p>
<p>We will work with the following type language. There are four kinds of function types. (1) Function which takes some parameters and returns a value, (2) function which takes some parameters but no return value, (3) Parameterless function with return value, and (4) Parameterless function with no return value.</p>
<pre><code>Ty         ::= int | bool | cmd | chan
             | func (Tys) T | func(Tys) | func() T | func()
Tys        ::= Ty | Ty, Tys</code></pre>
<p>The type checking rules traverse over the structure of programs. To keep track of the type of variables and functions, we record them some environment <code>G</code>.</p>
<pre><code>G          ::= ()
             |  (x : Ty)
             |  G ++ G</code></pre>
<p>We assume that <code>++</code> overwrites any 'earlier' binding.</p>
<p>Here are a few examples.</p>
<pre><code>() ++ (x : int)         =    (x : int)

(x : int) ++ (x : bool) = (x : bool)</code></pre>
<p>Let's take a look at the various typing rules.</p>
<h3 id="expressions">Expressions</h3>
<p>Judgments of the form <code>G |- bexp : Ty</code>.</p>
<pre><code>G |- i : int

G |- true : bool

G |- false : bool

G(x) = Ty
------------------
G |- x : Ty

G |- cexp1 : bool    G |- cexp2 : bool
----------------------------------------
G |- cexp1 &amp;&amp; cexp2 : bool

G |- cterm1 : Ty1   G |- cterm2 : Ty2
Ty1 and Ty2 denote the same type
----------------------------------------
G |- cterm1 == cterm2 : bool

G |- cterm1 : Ty1   G |- cterm2 : Ty2
Ty1 and Ty2 denote the same type
----------------------------------------
G |- cterm1 &gt; cterm2 : bool

G |- term1 : int   G |- term1 : int
-------------------------------------
G |- term1 + term2 : int

G |- term1 : int   G |- term1 : int
-------------------------------------
G |- term1 - term2 : int

G |- f : func(T1,..,Tn) T
G |- bi : Ti for i=1,...,n
---------------------------------------------------------------
G |- f(b1,...,bn) : T

etc</code></pre>
<p><em>Axioms</em> are rules with no precondition. For example, consider</p>
<pre><code>G |- i : int</code></pre>
<p>where <code>i</code> represents an integer (in terms of our syntax a sequence of digits).</p>
<p>Rules with precondition are written as</p>
<pre><code>Premise
---------
Conclusion</code></pre>
<p>If the <em>Premise</em> holds, the we can derive the <em>Conclusion</em>. For example, consider</p>
<pre><code>G(x) = Ty
------------------
G |- x : Ty</code></pre>
<p>If the variable <code>x</code> is assigned to type <code>Ty</code> in environment <code>G</code>, then we can derive that <code>x</code> is indeed of type <code>Ty</code>.</p>
<h3 id="statements">Statements</h3>
<p>Judgments of the form <code>G |- (statement : cmd | G)</code>.</p>
<p>Notice that we find a type binding on the left of <code>|-</code> (input) as well as on the right of <code>|-</code> (output). The reason is that variables can be declared anywhere (and not only at the beginning of a code block like in C). Examples will follow. Here come the typing rules for statements.</p>
<pre><code>G |- (statement1 : cmd|G1)   G1 |- (statement2 : cmd|G2)
------------------------------------------------------
G |- (statement1 ; statement2 : cmd|G2)

    thread through environment

G |- (statement : cmd|G2)
-----------------------------
G |- (go { statement } : cmd : G)

   variable declarations in some inner block are not visible outside

G |- x : chan   G |- aexp : int
---------------------------------
G |- (x &lt;- aexp : cmd|G)

G |- (x := newChannel : cmd | G ++ (x : chan))

G |- x : Ty   G |- bexp : Ty
-------------------------------
G |- (x = bexp : cmd | G)

G |- bexp : Ty
--------------------------------------
G |- (x := bexp : cmd | G ++ (x:Ty))

G |- bexp : bool   G |- (statement : cmd | G2)
----------------------------------------------
G |- (while bexp { statement } : cmd | G)

G |- bexp : bool  G |- (statement1 : cmd | G1)   G |- (statement2 : cmd | G2)
------------------------------------------------------------------------------
G |- (if bexp { statement1 } else {statement2} : cmd | G)

G |- f : func(T1,..,Tn) T
G |- bi : Ti for i=1,...,n
---------------------------------------------------------------
G |- (f(b1,...,bn) : cmd | G)

Last rule checks for function calls to ensure that
the arguments match the function declaration.
The return type T is optional.</code></pre>
<h3 id="program">Program</h3>
<p>Judgments <code>proc |- G</code> to collect all function type declarations. This pre-processing step is necessary as we want to support (mutually) recursive functions.</p>
<pre><code>block |- ()

proc |- G
----------------------------------------------------------------------
func x (x1 T1, ..., xn Tn) T block proc |- (f : func(T1,...,Tn) T) ++ G


proc |- G
----------------------------------------------------------------------
func x (x1 T1, ..., xn Tn) block proc |- (f : func(T1,...,Tn)) ++ G

proc |- G
----------------------------------------------------------------------
func x () T block proc |- (f : func() T) ++ G

proc |- G
----------------------------------------------------------------------
func x () block proc |- (f : func()) ++ G</code></pre>
<p>The first rule represents the base case. There are no functions to collect. The remaining four rules collect the type of the leading function. As we have four kinds of functions (combination of with/without parameter and with/without return type), we have four rules.</p>
<p>Notation: <code>func x (x1 T1, ..., xn Tn) T block proc</code> represents a program with some leading function <code>func x (x1 T1, ..., xn Tn) T block</code> followed by some <code>proc</code>.</p>
<p>Once we have collected all function type declarations, we can type check the function bodies (including main which corresponds to the last block. For this task, we use judgments <code>G |- proc</code>. Recall that <code>&quot;{&quot; statement &quot;}&quot;</code> corresponds to <code>block</code>.</p>
<pre><code>G |- (statement | _)
--------------------------
G |- &quot;{&quot; statement &quot;}&quot;

G |- block
G |- proc
----------------------------------------------
G |- func x (x1 T1, ..., xn Tn) T block proc</code></pre>
<p>Judgment <code>|- proc</code> represents the 'main' typing checking rule.</p>
<pre><code>proc |- G

G |- proc
------------------------------
|- proc</code></pre>
<h3 id="discussion">Discussion</h3>
<p>A few important points to note.</p>
<h4 id="scoping-rules">Scoping Rules</h4>
<p>Our typing rules ensure that bindings in some inner block are not visible in the surrounding block.</p>
<p>Consider</p>
<pre><code>{
   x := false;
   while x { x := 1 };
   x = true
}</code></pre>
<p>Within the body of the while loop we declare <code>x</code> to be an Integer variable whereas <code>x</code> is a Boolean variable in the surrounding block.</p>
<p>Here's some informal reasoning. Lexical scoping mean that any (re)declaration of an existing variable will overshade any declaration from the outerscope. Looking at your example (doing some slight reformatting).</p>
<pre><code>{
   x := false;     // L0: introduce Boolean variable x
   while x {       // L1: access variable declared at L0
      x := 1        // L2: redeclare x as Integer
    };
   x = true        // L3: access variable declared at L0
}</code></pre>
<p>More formally, let's verify that the above program indeed type checks. We claim that the judgment</p>
<pre><code>() |- (x := false; while x { x := 1 } : cmd | (x : bool))</code></pre>
<p>holds. That is, the program type checks and within this scope we find a variable of type <code>bool</code>.</p>
<p>Here is the derivation tree for the above judgment. The root of the (up-side down) tree is our to be verified judgment. Nodes are application of typing rules where leave nodes are axiomatic rules (without a premise).</p>
<pre><code>                                                            (x:bool) |- 1 : int
                                                            G2 = (x:bool) ++ (x:int) = (x:int) 
                                                           ---------------------------------------
  () |- false : bool                 (x:bool) | x : bool   (x:bool) |- (x := 1 : cmd | G2)
-------------------------------      --------------------------------------------------
() |- (x := false:cmd| (x:bool))     (x:bool) |- while x { x := 1 } : cmd | (x : bool))
----------------------------------------------------------------------------------------
() |- (x := false; while x { x := 1 } : cmd | (x : bool))</code></pre>
<p>Note that the binding <code>G2</code> is only visible within the body of the while loop.</p>
<p>Let us consider another example.</p>
<pre><code>{
  x := 1;         // P1
  x = x + 1;      // P2
  y := x + 2;     // P3
  x = y;
}</code></pre>
<p>The point of this example is that variables can be declared anywhere (and not only at the beginning of a code block like in C).</p>
<p>At program point P1, we introduce variable <code>x</code>. Some assignement follows at program point P2. At P3, we introduce yet another variable <code>y</code>. We omit to give the type derivation tree but annotate the program with the type bindings which are available at some program points. See below.</p>
<pre><code>{
  // G = ()
  x := 1;         // P1
  // G1 = (x : int)
  x = x + 1;      // P2
  // G1 = (x : int)  
  y := x + 2;     // P3
  // G2 = (x : int)++(y : int)
  x = y;
}</code></pre>
<h4 id="redeclarations-are-allowed-within-same-block">Redeclarations are allowed within same block</h4>
<p>Our rules allow for redeclarations within the same block. For example, the following program will type check!</p>
<pre><code>{
   x := 1 ;
   x := false
}</code></pre>
<p>How could we disallow redeclarations?</p>
<p>We could impose the following (additional) side condition</p>
<pre><code>G |- bexp : Ty
there&#39;s no Ty2 such that G(x) = Ty2
--------------------------------------
G |- (x := bexp : cmd | G ++ (x:Ty))</code></pre>
<p>The side condition</p>
<pre><code>there&#39;s no Ty2 such that G(x) = Ty2</code></pre>
<p>ensures that there's no binding for x within the same scope.</p>
<p>Thus, the above program will not type check. However, the additional side condition will also forbid programs such as</p>
<pre><code>{
   x := false;
   while x { x := 1 };
   x = true
}</code></pre>
<p>Hence, the solution to forbid redeclarations in the same scope but otherwise allow for redeclarations is a bit more complicated. We need to attach a scope number (level) to each variable annotation. In case an existing variable is redeclared we check that their scope annotations are different.</p>
<p><b>Your choice</b>: Your compiler ought to support redeclarations when moving from an outer to an inner block. It is your choice if you want to support redeclarations within the same block.</p>
</div>
<div id="dynamic-semantics" class="slide section level1">
<h1>Dynamic Semantics</h1>
<p>We seek for a machine-independent description of the dynamic (run-time) behavior of Mini-Go programs.</p>
<ul>
<li><p>Step-wise program execution based on an abstract machine</p></li>
<li><p>Ignore low-level details (register allocation, compilation of functions, ...)</p></li>
<li><p>Reference implementation</p></li>
</ul>
<h2 id="expressions-1">Expressions</h2>
<p>Expressions <code>bexp</code> operate on a program state which maps variables to values.</p>
<pre><code>V       ::=   i             -- Integer
        |    true | false   -- Booleans

S      ::=    ()            -- Empty state
        |     (x |-&gt; V)     -- Mapping of x to value V
        |     S ++ S        -- State extension</code></pre>
<p>We assume that a 'later' mapping overrules an 'earlier' mapping. For example,</p>
<pre><code>(x |-&gt; 1) ++ (x |-&gt; 2)  = (x |-&gt; 2)</code></pre>
<p>To lookup the (value) binding of a variable <code>x</code> in a state <code>S</code>, we write <code>S(x)</code>. For example,</p>
<pre><code>S = (x |-&gt; 1) ++ (x |-&gt; 2)

S(x) = 2</code></pre>
<h3 id="side-effect-free-expressions">Side-Effect Free Expressions</h3>
<p>Expressions are (almost) side-effect free. The exception are expressions of the form</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">z = (&lt;- x) + <span class="dv">1</span></code></pre></div>
<p>The subexpression <code>&lt;- x</code> reads a value from a channel. This is potentially a blocking operation as we need to synchronize a read with a concurrent write.</p>
<p>To keep the up-coming semantic description of expressions simple, we simply 'lift' out such expressions. That is, the above program text is desugared as follows</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">x2 := &lt;- x
z = x2 + <span class="dv">1</span></code></pre></div>
<p>Here are the updated grammar rules</p>
<pre><code>statement ::= ...
           |   vars &quot;:=&quot; &quot;&lt;-&quot; vars

factor ::=  ints | bools | vars | &quot;!&quot; factor | &quot;(&quot; bexp &quot;)&quot;</code></pre>
<p>Thus, expressions <code>bexp</code> are side-effect free and their dynamic semantic description is rather straightforward.</p>
<h3 id="expression-evaluation-rules">Expression Evaluation Rules</h3>
<p>We use judgments of the form</p>
<pre><code>S |- bexp =&gt; V</code></pre>
<p>to describe that for state <code>S</code>, the expression <code>bexp</code> evaluates to the value <code>V</code>.</p>
<p>We assume that we operate on an <em>abstract</em> syntax where for example a sequence of digits (in the <em>concrete</em> syntax) is represented as some integer <code>i</code>.</p>
<p>There are two types of evaluation rules.</p>
<p><em>Axioms</em> are rules with no precondition.</p>
<pre><code>S |- i =&gt; i</code></pre>
<p>Rules with precondition. Typically written as</p>
<pre><code>Premise
---------
Conclusion</code></pre>
<p>If the <em>Premise</em> holds, the we can derive the <em>Conclusion</em>.</p>
<p>Here's a simple example.</p>
<pre><code>S(x) = v
------------------
S |- x =&gt; v</code></pre>
<p>If the variable x is defined in state S and x has the current value v, then x evaluates to x in state S.</p>
<p>Here comes the list of evaluation rules.</p>
<pre><code>(Value-I)  S |- i =&gt; i

(Value-B-F) S |- false =&gt; false

(Value-B-T) S |- true =&gt; true

          S(x) = v
(Var)    ------------------
          S |- x =&gt; v

         S |- cexp1 =&gt; false                
(AndF)   ---------------------              
         S |- cexp1 &amp;&amp; cexp2 =&gt; false       

         S |- cexp1 =&gt; true   S |- cexp2 =&gt; v
(AndT)   ---------------------------------------
         S |- cexp1 &amp;&amp; cexp2 =&gt; v


         S |- cterm1 =&gt; v1    S |- cterm2 =&gt; v2
         v = primCmp(v1,v2)
(Cmp)    -------------------------------
         S |- cterm1 == cterm2 =&gt; v

         S |- aexp1 =&gt; v1     S |- aexp2 =&gt; v2
         v = primGT(v1,v2)
(GT)     --------------------------------------
         S |- aexp1 &gt; aexp2 =&gt; v         


         S |- term1 =&gt; v1   S |- term2 =&gt; v2
         v = primPlus(v1,v2)
(Plus)   ------------------------------------
         S |- term1 + term2 =&gt; v

         S |- term1 =&gt; v1   S |- term2 =&gt; v2
         v = primMinus(v1,v2)         
(Minus)  ---------------------------------------
         S |- term1 - term2 =&gt; v

         S |- factor1 =&gt; v1   S |- factor2 =&gt; v2
         v = primTimes(v1,v2)         
(Times)  ---------------------------------------
         S |- factor1 * factor2 =&gt; v

         S |- factor1 =&gt; v1   S |- factor2 =&gt; v2
         v = primDiv(v1,v2)
         v2 different from 0
(Div)    ---------------------------------------
         S |- factor1 / factor2 =&gt; v

         S |- factor =&gt; true
(Not-T)  -------------------------------
         S |- ! factor =&gt; false

         S |- factor =&gt; false
(Not-F)  -------------------------------
         S |- ! factor =&gt; true

         S |- bexp =&gt; v
(Paren)  ------------------
         S |- (bexp) =&gt; v</code></pre>
<p>Points to note:</p>
<p>Short-circuit evaluation in case of Boolean conjunction. Implies that Boolean conjunction in Mini-Go is not commutative! Consider <code>(false &amp;&amp; 1/0)</code>.</p>
<p>Primitive operations of our abstract machine.</p>
<pre><code>primCmp(true, false)  = false
primCmp(true, true)   = true
primCmp(false, false) = true
primCmp(false, true)  = false
primCmp(i, j)         = true     if i and j denote the same integer value
primCmp(i, j)         = false    if i and j denote different integer values

primGT, primPlus, primMinus, primTimes, primDiv definite analogously</code></pre>
<p>Evaluation may get stuck. For example, consider division by zero. Incompatible arguments.</p>
<h3 id="commutative-boolean-conjunction">Commutative Boolean conjunction</h3>
<p>Exercise: Implement <em>commutative</em> Boolean conjunction which obeys the short-circuit evaluation rule. Hint: Concurrent threads for each branch.</p>
<p>Updated semantics rules.</p>
<pre><code>           S |- cexp1 =&gt; false                
(AndF1)   ---------------------              
           S |- cexp1 &amp;&amp; cexp2 =&gt; false       

           S |- cexp1 =&gt; true   S |- cexp2 =&gt; v
(AndT1)   ---------------------------------------
           S |- cexp1 &amp;&amp; cexp2 =&gt; v

           S |- cexp2 =&gt; false                
(AndF2)   ---------------------              
           S |- cexp1 &amp;&amp; cexp2 =&gt; false       

           S |- cexp2 =&gt; true   S |- cexp1 =&gt; v
(AndT1)   ---------------------------------------
           S |- cexp1 &amp;&amp; cexp2 =&gt; v</code></pre>
<p>How to implement?</p>
<p>For each operand we create a thread and pass the result (if any) to the main thread via a channel.</p>
<h2 id="statements-1">Statements</h2>
<p>For 'plain' statements, judgments of the form <code>S |- statement =&gt; S</code> are sufficient. For example, consider</p>
<pre><code>S |- bexp =&gt; v    S2 = S ++ (x |-&gt; v)
---------------------------------------
S |- x = bexp =&gt; S2


S |- bexp =&gt; true   S |- statement1 =&gt; S2
------------------------------------------------------
S |- if bexp { statement1 } else { statement2 } =&gt; S2</code></pre>
<p>What about <code>go { statement }</code> and channel statements?</p>
<p>We need to support concurrently executing (sequences of) statements (also known as <em>threads</em>). Hence, we require judgments of the form</p>
<pre><code>(S|T1| ... |TM) =&gt; (S|T1|...|TN)</code></pre>
<p>where <code>S</code> is the program state and <code>Ti</code> are concurrent threads. We call <code>(S|T1| ... |TM)</code> a configuration.</p>
<p>Evaluation rules for statements are as follows.</p>
<p>NOTE: We assume that each channel primitive is preceded by a statement. Technically, we include a <code>skip</code> statement which shall be placed at the end of each thread.</p>
<p>NOTE: We assume that local variables in all threads (besides the main thread) are distinct (done by renaming). For example,</p>
<pre><code>{
 go { x := 0 } ;
 x := 1

}</code></pre>
<p>is renamed into</p>
<pre><code>{
 go { x2 := 0 } ;
 x := 1

}</code></pre>
<p>The technical reason (for renaming) is that we use a global state for all threads.</p>
<p>Here is the list of rules operating on configurations.</p>
<pre><code>(Go)     (S | go { statement1 }; statement2 | T1 | ... TN)
          =&gt;
         (S | statement2 | statement1 | T1 | ... TN)


         S |- bexp =&gt; v     S2 = S ++ (y |-&gt; v)
(Sync1)  ------------------------------------------------
         (S | x&lt;-bexp; statement1 | y:= &lt;-x; statement2)
          =&gt;
          (S2|statement1|statement2)

         S |- bexp =&gt; v     S2 = S ++ (y |-&gt; v)
(Sync2)  ------------------------------------------------
         (S | x&lt;-bexp; statement1 | y= &lt;-x; statement2)
          =&gt;
         (S2|statement1|statement2)


(Stop)   (S|skip|T2|...|TN) =&gt; (S|T2|...|TN)


             T1&#39;|...|TN&#39; is a permutation of T1|...|TN
(Schedule)  ------------------------------------------------------
            (S|T1|...|TN) =&gt; (S|T1&#39;|...|TN&#39;)


             (S|T) =&gt; (S&#39;|T&#39;)
(Step)       ------------------------------------------
             (S|T|T2|...|TN) =&gt; (S&#39;|T&#39;|T2|...|TN)

              S |- bexp =&gt; v  S&#39; = S ++ (x |-&gt; v)
(BexpDecl)   -------------------------------------
             (S|x := bexp; statement) =&gt; (S&#39; | statement)

              S |- bexp =&gt; v  S&#39; = S ++ (x |-&gt; v)
(BexpAsgn)   -------------------------------------
             (S|x = bexp; statement) =&gt; (S&#39; | statement)


(NewChannel)  (S| x := newChannel; statement) =&gt; (S | statement)

              S |- bexp =&gt; false
(WhileF)      ----------------------------------------------
              (S| while bexp { statement1 } ; statement2)
              =&gt;
              (S|statement2)

              S |- bexp =&gt; true
(WhileT)      ----------------------------------------------
              (S| while bexp { statement1 } ; statement2)
              =&gt;
              (S|statement1; while bexp { statement1 }; statement2)

              S |- bexp =&gt; true
(IfT)         ----------------------------------------
              (S| if bexp { statement1 } else {statement2} ; statement3)
              =&gt;
              (S|statement1; statement3)

              S |- bexp =&gt; false
(IfF)         ----------------------------------------
              (S| if bexp { statement1 } else {statement2} ; statement3)
              =&gt;
              (S|statement2; statement3)
                  </code></pre>
<p>All cases covered?</p>
<p>For brevity, we ignore <code>print aexp</code>. Technically, we would need to model the state of the screen/console.</p>
<p>For brevity, we ignore the statement <code>&lt;- vars</code> and assume that each statement statement is desugared into <code>x := &lt;- vars</code> where <code>x</code> is a fresh variable name.</p>
<p>Execution of a program <code>{ statement }</code> starts with the initial configuration <code>( () | statement)</code>.</p>
<p>Example evaluation.</p>
<pre><code>          ( () | x:=1 ; while x&lt;=1 { x=x+1} ; skip)
     =&gt;   ( (x |-&gt; 1) | while x&lt;=1 { x=x+1} ; skip)
     =&gt;   ( (x |-&gt; 1) | x=x+1; while x&lt;=1 { x=x+1} ; skip)
     =&gt;   ( (x |-&gt; 2) | while x&lt;=1 { x=x+1} ; skip)
     =&gt;   ( (x |-&gt; 2) | skip)</code></pre>
</div>
</body>
</html>
