<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Martin Sulzmann" />
  <title>Parser Combinators</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Parser Combinators</h1>
  <p class="author">
Martin Sulzmann
  </p>
</div>
<div id="functional-parsers" class="slide section level1">
<h1>Functional Parsers</h1>
<p>For concreteness, we will use Haskell. We could (to a large extent) equally well use Scala, C++11, Java8, ...</p>
<p>So, what is a parser?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Parser</span> s <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (s,<span class="dt">String</span>)</code></pre></div>
<ul>
<li><p>A parser is a function</p></li>
<li><p>The input is a string</p></li>
<li><p>The output is some result <code>s</code>, e.g. AST and the remaining string part we didn't process.</p></li>
</ul>
<p>A parser combinator is a special-purpose parsing function. For example, consider</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">num ::</span> <span class="dt">Parser</span> <span class="dt">Int</span></code></pre></div>
<p>which parses digits and turns them into integer numbers</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">num <span class="st">&quot;0123 + 234&quot;</span>  <span class="fu">==&gt;</span> (<span class="dt">IntVal</span> <span class="dv">123</span>,<span class="st">&quot; + 234&quot;</span>)</code></pre></div>
<p>There are two issues we need to address:</p>
<ul>
<li>Parsing my fail, for example consider</li>
</ul>
<pre><code>num &quot;xyz&quot;</code></pre>
<ul>
<li>The result of parsing may be ambiguous, for example consider <code>exp &quot;1+2*3&quot;</code> where <code>exp</code> parses expressions. The result could be either one of the following two</li>
</ul>
<pre><code>  Add (IntVal 1) (Mul (IntVal 2) (IntVal 3))

  Mul (Add (IntVal 1) (IntVal 2)) (IntVal 3)</code></pre>
<p>To address the above, we simply return a list of possible parse results</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Parser</span> s <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [(s,<span class="dt">String</span>)]</code></pre></div>
<p>Technically, this makes parsing non-deterministic but we will always favor the <em>first</em> result</p>
</div>
<div id="roll-your-own-monad---the-parser-monad" class="slide section level1">
<h1>Roll your own Monad - The Parser Monad</h1>
<p>A parser is a function which takes a string and yields a result (of some type <code>a</code>) and the remaining string. Our parser even yields a list of possible parse results, although, we will generally always favor the first successful parse result.</p>
<p>What's the deal with <em>monads</em>? It's a technical term to refer to side-effecting computations. Parsing produces a result, e.g. AST, and as a side-effect consumes (parts) of some input string.</p>
<h2 id="the-parser-function">The parser function</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">Parser</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> [(a,<span class="dt">String</span>)])</code></pre></div>
<p>Running the parser is simple. Apply the parse function on some input string.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">Parser</span> t <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [(t, <span class="dt">String</span>)]
run (<span class="dt">Parser</span> p) s <span class="fu">=</span> p s</code></pre></div>
<p>A practical use of this parser appears rather clumsy. As it seems we need to explicitly thread through the parser function and its parser state. Fortunately, we can capture the essence of our parser in a monad.</p>
<h2 id="basic-monadic-parser-combinators">Basic Monadic Parser Combinators</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Parser</span> <span class="kw">where</span>
  return a <span class="fu">=</span> <span class="dt">Parser</span> (\cs <span class="ot">-&gt;</span> [(a,cs)])
  p <span class="fu">&gt;&gt;=</span> f  <span class="fu">=</span> <span class="dt">Parser</span> (\cs <span class="ot">-&gt;</span> concat [parse (f a) cs&#39; <span class="fu">|</span> (a,cs&#39;) <span class="ot">&lt;-</span> parse p cs])

parse (<span class="dt">Parser</span> p) <span class="fu">=</span> p</code></pre></div>
<ul>
<li><p>The <code>return</code> function returns its arguments and leaves the input unchanged.</p></li>
<li><p>The <code>&gt;&gt;=</code> takes as its first argument a parse result <code>Parser a</code> and as its second argment a function <code>b -&gt; Parser b</code> which consumes the result and produces a new parser.</p></li>
<li><p>Helper <code>concat</code> combines the individual results and <code>parse</code> extracts the parsing function.</p></li>
</ul>
<p>Thanks to the <code>do</code> syntax the specification of parsers becomes straightforward as we will see shortly.</p>
<p>First, we define another set of combinators to signal failure and combine the sets (i.e. lists) of different parse results.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MonadPlus</span> <span class="dt">Parser</span> <span class="kw">where</span>
  mzero <span class="fu">=</span> <span class="dt">Parser</span> (\cs <span class="ot">-&gt;</span>[])
  p <span class="ot">`mplus`</span> q <span class="fu">=</span> <span class="dt">Parser</span> (\cs <span class="ot">-&gt;</span> parse p cs <span class="fu">++</span> parse q cs)</code></pre></div>
<h2 id="monad-laws">Monad Laws</h2>
<p>Besides a systematic way to specify computations via combinators <code>return</code> and `&gt;&gt;=', we assume that monad definitions satisfy certain laws such as left/right identity and associativity. Otherwise, the &quot;computation&quot; is not a monad. Our parser monad satisfies the monad laws. For those you are interested in the details, please check out <a href="Monad%20laws">http://www.haskell.org/haskellwiki/Monad_laws</a></p>
<h2 id="some-derived-combinators">Some derived combinators</h2>
<p>Now, the fun starts. Let's define some parser abstractions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(+++) ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
(<span class="fu">+++</span>) p q <span class="fu">=</span> <span class="dt">Parser</span> ( \cs <span class="ot">-&gt;</span> <span class="kw">case</span> parse (p <span class="ot">`mplus`</span> q) cs <span class="kw">of</span>
                           []     <span class="ot">-&gt;</span> []
                           (x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> [x] )

<span class="ot">item ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
item <span class="fu">=</span> <span class="dt">Parser</span> (\cs <span class="ot">-&gt;</span> <span class="kw">case</span> cs <span class="kw">of</span>
                       <span class="st">&quot;&quot;</span>     <span class="ot">-&gt;</span> []
                       (c<span class="fu">:</span>cs) <span class="ot">-&gt;</span> [(c,cs)])</code></pre></div>
<ul>
<li><p><code>(+++)</code> implements a deterministic first choice among several parse results (e.g. could be used in an LL-style parser with arbitrary look-ahead)</p></li>
<li><p><code>item</code> unconditionally parse a single character</p></li>
</ul>
<h2 id="combinators-for-strings-and-characters">Combinators for strings and characters</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sat ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span>
sat p <span class="fu">=</span> <span class="kw">do</span> { c <span class="ot">&lt;-</span> item; <span class="kw">if</span> p c <span class="kw">then</span> return c <span class="kw">else</span> mzero }

<span class="ot">char ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span>
char c <span class="fu">=</span> sat (c <span class="fu">==</span>)

<span class="ot">string ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span>
string <span class="st">&quot;&quot;</span> <span class="fu">=</span> return <span class="st">&quot;&quot;</span>
string (c<span class="fu">:</span>cs) <span class="fu">=</span> <span class="kw">do</span> {char c; string cs; return (c<span class="fu">:</span>cs)}</code></pre></div>
<ul>
<li><code>sat</code> only parses a character if a condition is satisfied</li>
<li><code>char</code> is conveniently defined in terms of <code>sat</code></li>
<li><code>string</code> recurses over the given string</li>
<li>Above equivalent to (<code>;</code> versus layout rule)</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">string ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span>
string <span class="st">&quot;&quot;</span> <span class="fu">=</span> return <span class="st">&quot;&quot;</span>
string (c<span class="fu">:</span>cs) <span class="fu">=</span> <span class="kw">do</span>  char c
                    string cs
                    return (c<span class="fu">:</span>cs)</code></pre></div>
<h2 id="tokens">Tokens</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">space ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
space <span class="fu">=</span> many (sat (\c <span class="ot">-&gt;</span> <span class="kw">case</span> c <span class="kw">of</span>
                          <span class="ch">&#39; &#39;</span>  <span class="ot">-&gt;</span> <span class="dt">True</span>
                          <span class="ch">&#39;\t&#39;</span> <span class="ot">-&gt;</span> <span class="dt">True</span>
                          _    <span class="ot">-&gt;</span> <span class="dt">False</span>))

<span class="ot">token ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a 
token p <span class="fu">=</span> <span class="kw">do</span> {space; a <span class="ot">&lt;-</span> p; space; return a}</code></pre></div>
<p>In parsing, we are generally only interested in character sequences which are not separated by white-space (commonly referred to as a token).</p>
<p><code>token</code> parses a token and throws away any leading/trailing spaces</p>
<h2 id="combinators-for-optional-and-repetitive-parsing">Combinators for optional and repetitive parsing</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">option ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]
option p <span class="fu">=</span> (<span class="kw">do</span> x <span class="ot">&lt;-</span> p
               return [x])
           <span class="fu">+++</span> return []

<span class="ot">many ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]
many p <span class="fu">=</span> many1 p <span class="fu">+++</span> return []

<span class="ot">many1 ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]
many1 p <span class="fu">=</span> <span class="kw">do</span> {a <span class="ot">&lt;-</span> p; as <span class="ot">&lt;-</span> many p; return (a<span class="fu">:</span>as)}</code></pre></div>
<ul>
<li><code>option</code> makes use of the indeterminism provided by our parser</li>
<li><code>many</code> takes a parser which will be parsed zero ore more times.</li>
<li><code>many1</code> requires at least one parse</li>
</ul>
</div>
<div id="application-parse-csv-file" class="slide section level1">
<h1>Application: Parse CSV File</h1>
<p>First, we define a parser function for digits where the digits are immediately turned into their integer representation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">digit c 
 <span class="fu">|</span> <span class="ch">&#39;0&#39;</span> <span class="fu">&lt;=</span> c <span class="fu">&amp;&amp;</span> c <span class="fu">&lt;=</span> <span class="ch">&#39;9&#39;</span> <span class="fu">=</span> <span class="dt">True</span>
 <span class="fu">|</span> otherwise            <span class="fu">=</span> <span class="dt">False</span>

<span class="ot">parseDigits ::</span> <span class="dt">Parser</span> <span class="dt">Int</span>
parseDigits <span class="fu">=</span> <span class="kw">do</span>
   i <span class="ot">&lt;-</span> token <span class="fu">$</span> many <span class="fu">$</span> sat digit
   return (read<span class="ot"> i ::</span> <span class="dt">Int</span>)
          <span class="co">-- read never fails here</span></code></pre></div>
<p>In the above, we make use of operator <code>$</code> to specify function applications by omitting parantheses. The expression <code>token $ many $ sat digit</code> is equivalent to <code>token (many (sat digit))</code></p>
<p>In regular expression notation, <code>parseDigits</code> expresses</p>
<pre><code>[&#39;0&#39;-&#39;9]+</code></pre>
<p>Additionally, in function <code>parseDigits</code> we ignore white-space and convert the sequence of digits into an integer value.</p>
<p>Next, we consider parsing of a single line consisting of a student ID and a sequence of marks. We assume that each line is terminated by &quot;new line&quot;. during parsing, we immediately sum up the marks.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">studentID <span class="fu">=</span> parseDigits
mark <span class="fu">=</span> parseDigits

delimiter <span class="fu">=</span> token <span class="fu">$</span> sat (<span class="fu">==</span><span class="ch">&#39;;&#39;</span>)

<span class="ot">parseAndSumLine ::</span> <span class="dt">Parser</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
parseAndSumLine <span class="fu">=</span> <span class="kw">do</span>
   id <span class="ot">&lt;-</span> studentID
   delimiter
   marks <span class="ot">&lt;-</span> many1 <span class="fu">$</span> <span class="kw">do</span> m <span class="ot">&lt;-</span> mark
                       delimiter
                       return m
   token <span class="fu">$</span> sat (<span class="fu">==</span><span class="ch">&#39;\n&#39;</span>)
   return (id,sum marks)</code></pre></div>
<p>In regular expression notation, the above is (roughly) equivalent to</p>
<pre><code> [&#39;0&#39;-&#39;9&#39;]+ ; ([&#39;0&#39;-&#39;9&#39;]+ ;)+ &#39;\n&#39;</code></pre>
<p>Additionaly, function <code>parseAndSumLine</code> extracts the student ID and immediately sums up the list of marks.</p>
<p>Parsing the complete file is straightforward.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">parseCSV <span class="fu">=</span> many1 parseAndSumLine</code></pre></div>
<p>Here's the a variant of the earlier function <code>sumCVSFile</code> which uses our simple CSV parser.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sumCSVFile fileName <span class="fu">=</span> <span class="kw">do</span>
   content <span class="ot">&lt;-</span> readFile fileName
   <span class="kw">case</span> (run parseCSV content) <span class="kw">of</span>
    ((xs,_)<span class="fu">:</span>_) <span class="ot">-&gt;</span> <span class="kw">do</span> 
       <span class="kw">let</span> output <span class="fu">=</span> unlines <span class="fu">$</span> 
                    map (\(id,m) <span class="ot">-&gt;</span> show id <span class="fu">++</span> <span class="st">&quot; ; &quot;</span> <span class="fu">++</span> show m <span class="fu">++</span> <span class="st">&quot; ; &quot;</span>) xs
       writeFile (fileName <span class="fu">++</span> <span class="st">&quot;.sum&quot;</span>) output

    [] <span class="ot">-&gt;</span> error <span class="st">&quot;parse failure&quot;</span>

testSumCSVFile <span class="fu">=</span> sumCSVFile <span class="st">&quot;sampleCSVFile.csv&quot;</span></code></pre></div>
</div>
<div id="imp-parser" class="slide section level1">
<h1>IMP Parser</h1>
<h2 id="abstract-syntax-of-imp">Abstract syntax of IMP</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Syntax</span> <span class="kw">where</span>

<span class="kw">type</span> <span class="dt">Var</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">data</span> <span class="dt">Val</span> <span class="fu">=</span> <span class="dt">N</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">BTrue</span> <span class="fu">|</span> <span class="dt">BFalse</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">Val</span> <span class="dt">Val</span> <span class="fu">|</span> <span class="dt">Id</span> <span class="dt">Var</span> <span class="fu">|</span> <span class="dt">Plus</span> <span class="dt">Exp</span> <span class="dt">Exp</span> <span class="fu">|</span> <span class="dt">Minus</span> <span class="dt">Exp</span> <span class="dt">Exp</span> <span class="fu">|</span> <span class="dt">Times</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Div</span> <span class="dt">Exp</span> <span class="dt">Exp</span> <span class="fu">|</span> <span class="dt">Equal</span> <span class="dt">Exp</span> <span class="dt">Exp</span> <span class="fu">|</span> <span class="dt">Gt</span> <span class="dt">Exp</span> <span class="dt">Exp</span> <span class="fu">|</span> <span class="dt">And</span> <span class="dt">Exp</span> <span class="dt">Exp</span> <span class="fu">|</span> <span class="dt">Not</span> <span class="dt">Exp</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">data</span> <span class="dt">Cmd</span> <span class="fu">=</span> <span class="dt">Skip</span> <span class="fu">|</span> <span class="dt">Assign</span> <span class="dt">Var</span> <span class="dt">Exp</span> <span class="fu">|</span> <span class="dt">Seq</span> <span class="dt">Cmd</span> <span class="dt">Cmd</span> <span class="fu">|</span> <span class="dt">ITE</span> <span class="dt">Exp</span> <span class="dt">Cmd</span> <span class="dt">Cmd</span> 
         <span class="fu">|</span> <span class="dt">While</span> <span class="dt">Exp</span> <span class="dt">Cmd</span> <span class="fu">|</span> <span class="dt">Newvar</span> <span class="dt">Var</span> <span class="dt">Exp</span> <span class="dt">Cmd</span> <span class="fu">|</span> <span class="dt">Print</span> <span class="dt">Var</span>
         <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<h2 id="imp-parser-1">IMP Parser</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">-- IMP Parser</span>

<span class="kw">module</span> <span class="dt">Parser</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad</span>

<span class="kw">import </span><span class="dt">Syntax</span>

<span class="co">-- We define our own &#39;simple&#39; parser combinator library.</span>
<span class="co">-- In practice, we should use a much better performing library such as Parsec.</span>

<span class="fu">------------------------------------------------------</span>
<span class="co">-- The Parser Monad</span>

<span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">Parser</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> [(a,<span class="dt">String</span>)])

<span class="ot">run ::</span> <span class="dt">Parser</span> t <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [(t, <span class="dt">String</span>)]
run (<span class="dt">Parser</span> p) s <span class="fu">=</span> p s

parse (<span class="dt">Parser</span> p) <span class="fu">=</span> p

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Parser</span> <span class="kw">where</span>
  return a <span class="fu">=</span> <span class="dt">Parser</span> (\cs <span class="ot">-&gt;</span> [(a,cs)])
  p <span class="fu">&gt;&gt;=</span> f  <span class="fu">=</span> <span class="dt">Parser</span> (\cs <span class="ot">-&gt;</span> concat [parse (f a) cs&#39; <span class="fu">|</span> (a,cs&#39;) <span class="ot">&lt;-</span> parse p cs])


<span class="kw">instance</span> <span class="dt">MonadPlus</span> <span class="dt">Parser</span> <span class="kw">where</span>
  mzero <span class="fu">=</span> <span class="dt">Parser</span> (\cs <span class="ot">-&gt;</span>[])
  p <span class="ot">`mplus`</span> q <span class="fu">=</span> <span class="dt">Parser</span> (\cs <span class="ot">-&gt;</span> parse p cs <span class="fu">++</span> parse q cs)

<span class="fu">------------------------</span>
<span class="co">-- Some combinators </span>


<span class="co">-- deterministic (first) choice</span>
<span class="ot">(+++) ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
(<span class="fu">+++</span>) p q <span class="fu">=</span> <span class="dt">Parser</span> ( \cs <span class="ot">-&gt;</span> <span class="kw">case</span> parse (p <span class="ot">`mplus`</span> q) cs <span class="kw">of</span>
                           []     <span class="ot">-&gt;</span> []
                           (x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> [x] )

<span class="ot">try ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
try p <span class="fu">=</span> <span class="dt">Parser</span> ( \cs <span class="ot">-&gt;</span> <span class="kw">case</span> parse p cs <span class="kw">of</span>
                          []     <span class="ot">-&gt;</span> [(undefined,cs)]
                          (x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> [x] )


<span class="co">-- unconditionally parse a single character</span>
<span class="ot">item ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
item <span class="fu">=</span> <span class="dt">Parser</span> (\cs <span class="ot">-&gt;</span> <span class="kw">case</span> cs <span class="kw">of</span>
                       <span class="st">&quot;&quot;</span>     <span class="ot">-&gt;</span> []
                       (c<span class="fu">:</span>cs) <span class="ot">-&gt;</span> [(c,cs)])



<span class="ot">sat ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span>
sat p <span class="fu">=</span> <span class="kw">do</span> { c <span class="ot">&lt;-</span> item; <span class="kw">if</span> p c <span class="kw">then</span> return c <span class="kw">else</span> mzero }

<span class="ot">char ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span>
char c <span class="fu">=</span> sat (c <span class="fu">==</span>)

<span class="co">-- parse a specific string</span>
<span class="ot">string ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span>
string <span class="st">&quot;&quot;</span> <span class="fu">=</span> return <span class="st">&quot;&quot;</span>
string (c<span class="fu">:</span>cs) <span class="fu">=</span> <span class="kw">do</span> {char c; string cs; return (c<span class="fu">:</span>cs)}


<span class="co">-- option</span>
<span class="ot">option ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]
option p <span class="fu">=</span> (<span class="kw">do</span> x <span class="ot">&lt;-</span> p
               return [x])
           <span class="fu">+++</span> return []

<span class="co">-- zero or more repetitions</span>
<span class="ot">many ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]
many p <span class="fu">=</span> many1 p <span class="fu">+++</span> return []

<span class="co">-- one or more repetitions</span>
<span class="ot">many1 ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]
many1 p <span class="fu">=</span> <span class="kw">do</span> {a <span class="ot">&lt;-</span> p; as <span class="ot">&lt;-</span> many p; return (a<span class="fu">:</span>as)}


<span class="co">-- parse a token, throwing away any leading/trailing spaces</span>
<span class="ot">token ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a 
token p <span class="fu">=</span> <span class="kw">do</span> {space; a <span class="ot">&lt;-</span> p; space; return a}


<span class="co">-- string token</span>
<span class="ot">stoken ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span>
stoken s <span class="fu">=</span> token <span class="fu">$</span> string s

<span class="co">-- parse a string of spaces, tabs</span>
<span class="ot">space ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
space <span class="fu">=</span> many (sat (\c <span class="ot">-&gt;</span> <span class="kw">case</span> c <span class="kw">of</span>
                          <span class="ch">&#39; &#39;</span>  <span class="ot">-&gt;</span> <span class="dt">True</span>
                          <span class="ch">&#39;\t&#39;</span> <span class="ot">-&gt;</span> <span class="dt">True</span>
                          _    <span class="ot">-&gt;</span> <span class="dt">False</span>))


<span class="fu">-------------------------------------</span>
<span class="co">-- Application: parse IMP</span>


<span class="co">{-</span>

<span class="co">We roughly follow the EBNF style grammar notation</span>

<span class="co">http://en.wikipedia.org/wiki/Extended_Backus–Naur_Formhttp://en.wikipedia.org/wiki/Extended_Backus–Naur_Form</span>

<span class="co">{ ... } stands for repetition</span>

<span class="co">[ ... ] stands for option</span>



<span class="co">operator precedence from top (highest) to bottom (lowest)</span>

<span class="co">* /</span>
<span class="co">+ -</span>
<span class="co">&gt;</span>
<span class="co">==</span>
<span class="co">&amp;&amp;</span>
<span class="co">||   -- not supported</span>



<span class="co">prog ::=  decls &quot;{&quot; prog &quot;}&quot;</span>
<span class="co">      |   cmd { &quot;;&quot; prog  }</span>

<span class="co">decls ::= &quot;var&quot; decl { &quot;;&quot; decl }</span>

<span class="co">decl ::= vars &quot;:=&quot; bexp</span>

<span class="co">cmd ::= &quot;skip&quot;</span>
<span class="co">     | vars &quot;:=&quot; bexp</span>
<span class="co">     | &quot;if&quot; &quot;(&quot; bexp &quot;)&quot; &quot;{&quot; prog &quot;}&quot; &quot;else&quot; &quot;{&quot; prog &quot;}&quot;</span>
<span class="co">     | &quot;while&quot; &quot;(&quot; bexp &quot;)&quot; &quot;{&quot; prog &quot;}&quot;</span>
<span class="co">     | &quot;print&quot; vars</span>


<span class="co">bexp ::= cexp { &quot;&amp;&amp;&quot; cexp }</span>

<span class="co">cexp ::= cterm [ &quot;==&quot; cterm ]</span>

<span class="co">cterm ::= aexp [ &quot;&gt;&quot; aexp ]</span>

<span class="co">aexp ::= term { &quot;+&quot; term | &quot;-&quot; term }</span>

<span class="co">term ::= factor { &quot;*&quot; factor | &quot;/&quot; factor }</span>

<span class="co">factor ::=  ints | bools | vars | &quot;!&quot; factor | &quot;(&quot; bexp &quot;)&quot;</span>

<span class="co">digit ::= &#39;0&#39; | ... | &#39;9&#39;</span>

<span class="co">ints ::=  digit { digit }</span>

<span class="co">bools ::= &#39;true&#39; | &#39;false&#39;</span>

<span class="co">letter ::= &#39;a&#39; | ... | &#39;z&#39;</span>

<span class="co">vars ::=  letter { digit | letter }</span>

<span class="co">-}</span>


<span class="co">-- There&#39;s no proceeding lexing phase. </span>
<span class="co">-- We take care of white space by scanning </span>
<span class="co">-- operators and keywords via s(tring)token.</span>

<span class="ot">prog ::</span> <span class="dt">Parser</span> <span class="dt">Cmd</span>
prog <span class="fu">=</span> (<span class="kw">do</span> try <span class="fu">$</span> stoken <span class="st">&quot;var&quot;</span>
           (v,e) <span class="ot">&lt;-</span> decl
           ds <span class="ot">&lt;-</span> many <span class="fu">$</span> <span class="kw">do</span> stoken <span class="st">&quot;;&quot;</span>
                           d <span class="ot">&lt;-</span> decl
                           return d
           stoken <span class="st">&quot;{&quot;</span>
           p <span class="ot">&lt;-</span> prog
           stoken <span class="st">&quot;}&quot;</span>
           return <span class="fu">$</span> foldl (\c <span class="ot">-&gt;</span> \(v,e) <span class="ot">-&gt;</span> <span class="dt">Newvar</span> v e c) 
                          (<span class="dt">Newvar</span> v e p) 
                          ds)
       <span class="fu">+++</span>
       (<span class="kw">do</span> c <span class="ot">&lt;-</span> cmd
           cs <span class="ot">&lt;-</span> many <span class="fu">$</span> <span class="kw">do</span> stoken <span class="st">&quot;;&quot;</span>
                           c <span class="ot">&lt;-</span> prog
                           return c
           return <span class="fu">$</span> foldl <span class="dt">Seq</span> c cs)
            

<span class="ot">decl ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>,<span class="dt">Exp</span>)
decl <span class="fu">=</span> <span class="kw">do</span> (<span class="dt">Id</span> x) <span class="ot">&lt;-</span> vars
          stoken <span class="st">&quot;:=&quot;</span>
          e <span class="ot">&lt;-</span> bexp
          return (x,e)

<span class="co">-- TODO: variables names such as ifx</span>
<span class="ot">cmd ::</span> <span class="dt">Parser</span> <span class="dt">Cmd</span>
cmd <span class="fu">=</span> (<span class="kw">do</span> stoken <span class="st">&quot;skip&quot;</span>
          return <span class="dt">Skip</span>)
      <span class="fu">+++</span>
      (<span class="kw">do</span> stoken <span class="st">&quot;print&quot;</span>
          (<span class="dt">Id</span> v) <span class="ot">&lt;-</span> vars
          return <span class="fu">$</span> <span class="dt">Print</span> v)
      <span class="fu">+++</span>
      (<span class="kw">do</span> stoken <span class="st">&quot;if&quot;</span>
          stoken <span class="st">&quot;(&quot;</span>
          b <span class="ot">&lt;-</span> bexp
          stoken <span class="st">&quot;)&quot;</span>
          stoken <span class="st">&quot;{&quot;</span>
          t <span class="ot">&lt;-</span> prog
          stoken <span class="st">&quot;}&quot;</span>
          stoken <span class="st">&quot;else&quot;</span>
          stoken <span class="st">&quot;{&quot;</span>
          e <span class="ot">&lt;-</span> prog
          stoken <span class="st">&quot;}&quot;</span>
          return <span class="fu">$</span> <span class="dt">ITE</span> b t e)
      <span class="fu">+++</span>
      (<span class="kw">do</span> stoken <span class="st">&quot;while&quot;</span>
          stoken <span class="st">&quot;(&quot;</span>
          b <span class="ot">&lt;-</span> bexp
          stoken <span class="st">&quot;)&quot;</span>
          stoken <span class="st">&quot;{&quot;</span>
          c <span class="ot">&lt;-</span> prog
          stoken <span class="st">&quot;}&quot;</span>
          return <span class="fu">$</span> <span class="dt">While</span> b c)
      <span class="fu">+++</span>
      (<span class="kw">do</span> (<span class="dt">Id</span> v) <span class="ot">&lt;-</span> vars
          stoken <span class="st">&quot;:=&quot;</span>
          b <span class="ot">&lt;-</span> bexp
          return <span class="fu">$</span> <span class="dt">Assign</span> v b)   


<span class="ot">bexp ::</span> <span class="dt">Parser</span> <span class="dt">Exp</span>
bexp <span class="fu">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> cexp
          ys <span class="ot">&lt;-</span> many <span class="fu">$</span> <span class="kw">do</span> stoken <span class="st">&quot;&amp;&amp;&quot;</span>
                          y <span class="ot">&lt;-</span> cexp
                          return y
          return <span class="fu">$</span> foldl <span class="dt">And</span> x ys

<span class="ot">cexp ::</span> <span class="dt">Parser</span> <span class="dt">Exp</span>
cexp <span class="fu">=</span>  <span class="kw">do</span> x <span class="ot">&lt;-</span> cterm
           ((<span class="kw">do</span> stoken <span class="st">&quot;==&quot;</span>
                y <span class="ot">&lt;-</span> cterm
                return <span class="fu">$</span> <span class="dt">Equal</span> x y)
             <span class="fu">+++</span>
             (return x))


<span class="ot">cterm ::</span> <span class="dt">Parser</span> <span class="dt">Exp</span>
cterm <span class="fu">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> aexp
           ((<span class="kw">do</span> stoken <span class="st">&quot;&gt;&quot;</span>
                y <span class="ot">&lt;-</span> aexp
                return <span class="fu">$</span> <span class="dt">Gt</span> x y)
            <span class="fu">+++</span>
            (return x))

<span class="co">-- +/- right associative</span>
<span class="ot">aexp ::</span> <span class="dt">Parser</span> <span class="dt">Exp</span>
aexp <span class="fu">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> term
          ys <span class="ot">&lt;-</span> many <span class="fu">$</span> (<span class="kw">do</span> stoken <span class="st">&quot;+&quot;</span>
                           y <span class="ot">&lt;-</span> term
                           return (<span class="ch">&#39;+&#39;</span>,y))
                       <span class="fu">+++</span>
                       (<span class="kw">do</span> stoken <span class="st">&quot;-&quot;</span>
                           y <span class="ot">&lt;-</span> term
                           return (<span class="ch">&#39;-&#39;</span>,y))
          return <span class="fu">$</span> foldl (\a <span class="ot">-&gt;</span> \(op,b) <span class="ot">-&gt;</span>
                             <span class="kw">case</span> op <span class="kw">of</span>
                               <span class="ch">&#39;+&#39;</span> <span class="ot">-&gt;</span> <span class="dt">Plus</span> a b
                               <span class="ch">&#39;-&#39;</span> <span class="ot">-&gt;</span> <span class="dt">Minus</span> a b)
                         x ys

<span class="ot">term ::</span> <span class="dt">Parser</span> <span class="dt">Exp</span>
term <span class="fu">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> factor
          ys <span class="ot">&lt;-</span> many <span class="fu">$</span> (<span class="kw">do</span> stoken <span class="st">&quot;*&quot;</span>
                           y <span class="ot">&lt;-</span> factor
                           return (<span class="ch">&#39;*&#39;</span>,y))
                       <span class="fu">+++</span>
                       (<span class="kw">do</span> stoken <span class="st">&quot;/&quot;</span>
                           y <span class="ot">&lt;-</span> factor
                           return (<span class="ch">&#39;/&#39;</span>,y))
          return <span class="fu">$</span> foldl (\a <span class="ot">-&gt;</span> \(op,b) <span class="ot">-&gt;</span>
                             <span class="kw">case</span> op <span class="kw">of</span>
                               <span class="ch">&#39;*&#39;</span> <span class="ot">-&gt;</span> <span class="dt">Times</span> a b
                               <span class="ch">&#39;/&#39;</span> <span class="ot">-&gt;</span> <span class="dt">Div</span> a b)
                         x ys

<span class="ot">factor ::</span> <span class="dt">Parser</span> <span class="dt">Exp</span>
factor <span class="fu">=</span> ints <span class="fu">+++</span> bools <span class="fu">+++</span> vars <span class="fu">+++</span>
         (<span class="kw">do</span> stoken <span class="st">&quot;!&quot;</span>
             x <span class="ot">&lt;-</span> factor
             return <span class="fu">$</span> <span class="dt">Not</span> x)
         <span class="fu">+++</span>
         (<span class="kw">do</span> (stoken <span class="st">&quot;(&quot;</span>)
             x <span class="ot">&lt;-</span> bexp
             stoken <span class="st">&quot;)&quot;</span>
             return x) 

isDigit c  <span class="fu">=</span> <span class="ch">&#39;0&#39;</span> <span class="fu">&lt;=</span> c <span class="fu">&amp;&amp;</span> c <span class="fu">&lt;=</span> <span class="ch">&#39;9&#39;</span> 

isLetter c <span class="fu">=</span> <span class="ch">&#39;a&#39;</span> <span class="fu">&lt;=</span> c <span class="fu">&amp;&amp;</span> c <span class="fu">&lt;=</span> <span class="ch">&#39;z&#39;</span>

<span class="ot">ints ::</span> <span class="dt">Parser</span> <span class="dt">Exp</span>
ints <span class="fu">=</span> <span class="kw">do</span>
   i <span class="ot">&lt;-</span> many1 <span class="fu">$</span> sat isDigit
   return <span class="fu">$</span> <span class="dt">Val</span> <span class="fu">$</span> <span class="dt">N</span> (read<span class="ot"> i ::</span> <span class="dt">Int</span>)
          <span class="co">-- read never fails here</span>

<span class="ot">bools ::</span> <span class="dt">Parser</span> <span class="dt">Exp</span>
bools <span class="fu">=</span> (<span class="kw">do</span> string <span class="st">&quot;true&quot;</span>
            return <span class="fu">$</span> <span class="dt">Val</span> <span class="dt">BTrue</span>)
         <span class="fu">+++</span> 
        (<span class="kw">do</span> string <span class="st">&quot;false&quot;</span>
            return <span class="fu">$</span> <span class="dt">Val</span> <span class="dt">BFalse</span>)

<span class="ot">vars ::</span> <span class="dt">Parser</span> <span class="dt">Exp</span>
vars <span class="fu">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> sat isLetter
          xs <span class="ot">&lt;-</span> many <span class="fu">$</span> sat (\c <span class="ot">-&gt;</span> isDigit c <span class="fu">||</span> isLetter c)
          return <span class="fu">$</span> <span class="dt">Id</span> (x<span class="fu">:</span>xs)</code></pre></div>
</div>
</body>
</html>
