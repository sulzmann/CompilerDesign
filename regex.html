<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Martin Sulzmann" />
  <title>Regular Expressions</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Regular Expressions</h1>
  <p class="author">
Martin Sulzmann
  </p>
</div>
<div id="overview" class="slide section level1">
<h1>Overview</h1>
<ul>
<li>Popular notation to specify (infinitely many) string patterns.</li>
</ul>
<pre><code>(a | b)*</code></pre>
<p>denotes the (infinite) set of strings</p>
<pre><code>&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;ab&quot;, &quot;ba&quot;, ...</code></pre>
<ul>
<li><p>Play vital role during the lexical analysis stage of a compiler.</p></li>
<li><p>Many (many) more useful applications exist (text search, formal specifications, ...)</p></li>
<li><p>We will take a look at the theory behind regular expressions.</p></li>
<li><p>Build a simple regular expression compiler (matcher).</p></li>
<li><p>So by the way we learn something about the various stages of a compiler.</p></li>
</ul>
</div>
<div id="a-regular-expression-compiler" class="slide section level1">
<h1>A Regular Expression Compiler</h1>
<p>Purpose: Check if a regular expression matches a string (word).</p>
<p>Things to talk about:</p>
<ul>
<li><p>Syntax</p></li>
<li><p>Semantics</p></li>
<li><p>Compilation</p></li>
</ul>
</div>
<div id="regular-expressions" class="slide section level1">
<h1>Regular Expressions</h1>
<h2 id="examples">Examples</h2>
<pre><code>ab* </code></pre>
<pre><code>(cd|a)</code></pre>
<pre><code>ab* | cd | a</code></pre>
<h2 id="informal-meaning">Informal Meaning</h2>
<pre><code>(cd|a)</code></pre>
<ul>
<li><p>Concatenation of symbols (letters) <code>c</code> and <code>d</code>, written <code>cd</code></p></li>
<li><p>Alternatives, written <code>|</code> (choice operator)</p></li>
</ul>
<p>What about?</p>
<pre><code>ab* </code></pre>
<ul>
<li><p>As we know, <code>*</code> stands for Kleene star (zero or more repetition)</p></li>
<li><p>Kleene star operator binds tighter than concatenation</p></li>
<li><p>So, the above corresponds to <code>a(b*)</code></p></li>
</ul>
<p>What about?</p>
<pre><code>ab* | cd | a</code></pre>
<ul>
<li><code>|</code> is commutative (order does not matter)</li>
</ul>
<h2 id="extensions">Extensions</h2>
<p>What about the following?</p>
<pre><code>ab+</code></pre>
<pre><code>cd? | e</code></pre>
<pre><code>^cb*</code></pre>
<p>We encounter three new (unary) operators. Two postfix operators (<code>+</code> and <code>?</code>) and one prefix operator (<code>^</code>).</p>
<ul>
<li><p><code>+</code> stands for one ore more repetitions</p></li>
<li><p><code>?</code> stands for optional expression</p></li>
<li><p><code>^</code> stands for negation</p></li>
</ul>
<p>As we will see, <code>+</code> and <code>?</code> can be desugared into existing set of regular expression operators whereas <code>^</code> requires a language extension.</p>
<h2 id="expressiveness">Expressiveness</h2>
<p>Provide some regular patterns to describe the following string patterns (if possible!).</p>
<ul>
<li><p>Arbitrary permutations of the letters <code>a</code> and <code>b</code>.</p></li>
<li><p>All strings (over letters <code>1</code> and <code>0</code>) that contain at least one <code>1</code>.</p></li>
<li><p>All strings that describe variable identifiers in Java.</p></li>
<li><p>All strings where for each opening parenthesis <code>(</code> there is a closing parenthesis <code>)</code>.</p></li>
</ul>
</div>
<div id="concrete-versus-abstract-syntax" class="slide section level1">
<h1>Concrete versus Abstract Syntax</h1>
<p>Concrete syntax:</p>
<ul>
<li><p>As seen by the user, convenient to use, rich set of operators</p></li>
<li><p>Typically defined in terms of some <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form">EBNF</a></p></li>
</ul>
<p>Abstract syntax:</p>
<ul>
<li><p>Compact representation of a (concrete) syntactic regular expression</p></li>
<li><p>Used for further automatic processing</p></li>
<li><p>Tree-like structure</p></li>
</ul>
<h2 id="concrete-syntax-in-ebnf">Concrete Syntax in EBNF</h2>
<pre><code>r ::= &#39;a&#39; | &#39;b&#39; | ...             Symbols aka letters taken from a finite alphabet
   |  r &#39;|&#39;  r                    Alternatives
   |  r r                         Concatenation
   | r &#39;*&#39;                        Kleene star
   | r &#39;+&#39;                        One or more repetitions
   | r &#39;?&#39;                        Option
   | &#39;(&#39; r &#39;)&#39;                    Parentheses</code></pre>
<ul>
<li><p>We ignore <code>^</code></p></li>
<li><p>Note the different between <code>|</code> and <code>'|'</code>. The former refers to the meta-symbol to represent alternatives at the level of EBNF whereas the letter refers to the object-symbol to represent alternatives among regular expressions.</p></li>
<li><p>We have ignored white space, tabs etc.</p></li>
</ul>
<h2 id="abstract-syntax-in-ebnf">Abstract Syntax in EBNF</h2>
<pre><code>r ::= &#39;a&#39; | &#39;b&#39; | ...             Symbols
   |  r &#39;|&#39;  r                    Alternatives
   |  r &#39;.&#39; r                     Concatenation
   | r &#39;+&#39;                        One or more repetitions
   | &quot;epsilon&quot;                    Empty string</code></pre>
<ul>
<li><p>Explicit operator for concatenation</p></li>
<li><p>Desugaring of (some of our) extensions</p></li>
</ul>
<pre><code>r*  ==&gt;   epsilon | r+

r?  ==&gt;   epsilon | r</code></pre>
<ul>
<li>Parentheses removed based on abstract syntax <b>tree</b> representation</li>
</ul>
<pre><code>(ab) | c   ==&gt;             |
                          / \
                         .   c
                        /  \
                       a    b    </code></pre>
<p>Aside: Consider the source expression <code>abc</code>. This expression is ambiguous because it has several abstract syntax tree (AST) representations. We will discuss this topic in more detail later (syntax analysis).</p>
<h2 id="parsing">Parsing</h2>
<p>Parsing is the process of transforming a source expression into an AST.</p>
<p>We largely ignore parsing for the moment and assume that regular expressions are represented in terms of some suitable abstract syntax (tree) format.</p>
</div>
<div id="language-semantics" class="slide section level1">
<h1>Language Semantics</h1>
<p>Before we can build a compiler we need a formal semantic description of the language.</p>
<p>As a user you expect that different compilers behave the same. Many languages (e.g. C) were lacking a formal semantic description and hence users were surprised to encounter differences among compilers.</p>
<p>At the time of C, formal semantic descriptions were not common and tools/methods for such descriptions were not quite up to standard yet. This has changed drastically nowadays. See C, Java (and its JVM).</p>
<p>Thankfully, the semantic description of regular expressions is pretty straightforward. From now on we will work with the following abstract syntax.</p>
<pre><code>r,s ::= a | b | c | ...         Symbols aka letters taken from a finite alphabet
    |  epsilon                  Empty word
    |  phi                      Empty language
    |  r + r                    Alternatives
    |  r . r                    Sequence aka concatenation
    |  r*                       Kleene star

u,v,w ::= epsilon               empty word
      |  w . w                  concatenation</code></pre>
<ul>
<li><p>Yes, I'm lazy and will drop quotes from now on.</p></li>
<li><p>We use <code>+</code> so we don't get confused with the EBNF meta-symbol <code>|</code>.</p></li>
<li><p>Why <code>phi</code> the empty language? We will see later.</p></li>
<li><p>Words and strings are used synonymously and denote sequences of letters.</p></li>
</ul>
<h2 id="lr">L(r)</h2>
<p><code>L(r)</code> denotes the set of words represented by the regular expression r.</p>
<p>Standard (denotational) formulation of L(r):</p>
<pre><code>L(x) = { x }

L(epsilon) = { epsilon }

L(phi) = { }

L(r + s) = { w | w in L(r) or w in L(s) }

L(r . s) = { v . w | v in L(r) and w in L(s) }

L(r*) = { epsilon } cap { w_1 . ... . w_n | w_1, ..., w_n in L(r) and n &gt;=1 }</code></pre>
<h2 id="towards-a-regular-expression-compilermatcher">Towards a Regular Expression Compiler/Matcher</h2>
<p>For us humans, regular expressions are a intuitive formalism to specify string patterns. For example, it is fairly easy to see that the string <code>a.b.a</code> is part of the language denotation of expression <code>(a+b)*</code>. That is, <code>a.b.a</code> is an element of <code>L((a+b)*)</code>. We say that expression <code>(a+b)*</code> matches the string <code>a.b.a</code>.</p>
<p>Aside: The abstract syntax does not (need to) support parentheses as we can always use the tree representation to unambiguously represent a regular expression. I'm making use of parentheses because I'm too lazy to draw the tree.</p>
<p>The question is how to automate the processing of checking that an expression matches a string? That is, we wish to compile regular expressions such that we can apply a systematic method for matching against a word.</p>
<h2 id="finite-state-machines-fsm">Finite State Machines (FSM)</h2>
<p>It is well understood how to convert a regular expression into a finite state machine. Roughly, a FSM consists of a finite set of states where execution starts in some initial state. Execution is driven by the consumption of symbols from some input string. Based on a state transition table which tells us where to move next (to which state) given our current state and input symbol, we can systematically process the input string. The string is accepted if we reach a designated (final) state.</p>
<p>We will consider two classic approaches to transform a regular expression (RegEx) into a FSM.</p>
<p>One approach turns the RegEx into a non-deterministic finite automate (=machine). Non-deterministic means that in the state transition table there are several entries for a given current state and input symbol. The other approach results in a deterministic finite automata.</p>
</div>
<div id="thompson-nfa-construction" class="slide section level1">
<h1>Thompson NFA Construction</h1>
<p>NFA = non-deterministic finite automata</p>
<p><b>Black/white board</b></p>
<p>See also Chapter 3.7 Dragon book or check <a href="https://en.wikipedia.org/wiki/Thompson%27s_construction">here</a>.</p>
<h2 id="how-to-implement-all-that">How to implement all that?</h2>
<p>As a start we consider a class-based language such as C++.</p>
<p><b>NOTE</b>: Our language of choice for this course is <a href="https://ocaml.org/">OCaml</a>. As the name hints OCaml also supports some object-oriented programming features. However, we will (as much as possible) stick to the functional subset of OCaml. To ease the pain of writing functional programs for those coming from a more OO background, we will therefore first consider a sketch of C++ implementation before moving on to an implementation in OCaml.</p>
<h3 id="sketch-in-c">Sketch in C++</h3>
<h4 id="fsa-representation">FSA Representation</h4>
<p>Some class to represent transitions.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Transition {
 <span class="kw">private</span>:
  <span class="dt">int</span> from; 
  <span class="dt">char</span> c; 
  <span class="dt">int</span> to;
  <span class="dt">bool</span> epsilon;
 <span class="kw">public</span>:

  Transition(<span class="dt">int</span> _from, <span class="dt">int</span> _to) {
    from = _from; to = _to; 
    epsilon = <span class="kw">true</span>;
  } 
  Transition(<span class="dt">int</span> _from, <span class="dt">char</span> _c, <span class="dt">int</span> _to) {
    from = _from; c = _c; to = _to; 
    epsilon = <span class="kw">false</span>;
  } 
  <span class="dt">bool</span> isEpsilonTransition() { <span class="kw">return</span> epsilon; }
  <span class="dt">int</span> toState() { <span class="kw">return</span> to; }
  <span class="dt">bool</span> trigger(<span class="dt">int</span> from, <span class="dt">char</span> c) {
    <span class="kw">return</span> (!epsilon &amp;&amp; from == <span class="kw">this</span>-&gt;from &amp;&amp; c == <span class="kw">this</span>-&gt;c);
  }
  <span class="dt">bool</span> trigger(<span class="dt">int</span> from) {
    <span class="kw">return</span> (epsilon &amp;&amp; from == <span class="kw">this</span>-&gt;from);
 }
};</code></pre></div>
<p>Classic OO abstraction to represent an NFA:</p>
<ul>
<li><p>Some member variables (aka instance variables) represent the structure of the automata.</p></li>
<li><p>Some methods for execution.</p></li>
<li><p>For fun split into two classes where <code>NFA</code> contains the data representation part and <code>FSA</code> contains the execution part.</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> NFA {
 <span class="kw">private</span>:
  vector&lt;Transition&gt; ts;
  <span class="dt">int</span> init;
  vector&lt;<span class="dt">int</span>&gt; <span class="kw">final</span>;

 <span class="kw">public</span>:
  NFA(vector&lt;Transition&gt; _ts, <span class="dt">int</span> _init, vector&lt;<span class="dt">int</span>&gt; _final) {
    ts = _ts;
    init = _init;
    <span class="kw">final</span> = _final;
  }
  NFA(vector&lt;Transition&gt; _ts, <span class="dt">int</span> _init, <span class="dt">int</span> _final) {
    ts = _ts;
    init = _init;
    <span class="kw">final</span>.push_back(_final);
  }
  vector&lt;Transition&gt; getTransitions() { <span class="kw">return</span> ts; }
  <span class="dt">int</span> getInitial() { <span class="kw">return</span> init; }
  vector&lt;<span class="dt">int</span>&gt; getFinals() { <span class="kw">return</span> <span class="kw">final</span>; }

  <span class="kw">friend</span> <span class="kw">class</span> FSA;
};

<span class="kw">class</span> FSA : <span class="kw">public</span> NFA {
 <span class="kw">private</span>:
  vector&lt;<span class="dt">int</span>&gt; current;
  <span class="dt">void</span> closure();
 <span class="kw">public</span>:
  FSA(NFA fsa) : NFA(fsa.ts,fsa.init,fsa.<span class="kw">final</span>) {
    current.push_back(init);
    closure();
  }
  <span class="dt">void</span> reset();
  <span class="dt">void</span> step(<span class="dt">char</span> c);
  <span class="dt">bool</span> isFinal();
  <span class="dt">bool</span> run(string s);

};

<span class="dt">void</span> FSA::reset() {
    current.clear();
    current.push_back(init);
    closure();
}

<span class="dt">bool</span> FSA::isFinal() {
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; <span class="kw">final</span>.size(); i++) {
      <span class="kw">if</span>(find(current.begin(),current.end(),<span class="kw">final</span>[i]) != current.end())
    <span class="kw">return</span> <span class="kw">true</span>;
    }     
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">void</span> FSA::closure() {
  <span class="co">// omit</span>
}

<span class="dt">void</span> FSA::step(<span class="dt">char</span> c) {
    vector&lt;<span class="dt">int</span>&gt; next;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; ts.size(); i++) {
      <span class="kw">for</span> (<span class="dt">int</span> j=<span class="dv">0</span>; j &lt; current.size(); j++) {
        <span class="kw">if</span>(ts[i].trigger(current[j],c))
      next.push_back(ts[i].toState());
      }
    }
    current = next;
    closure();
}

<span class="dt">bool</span> FSA::run(string s) {
  reset();
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; s.length(); i++) {
    step(s[i]);
  }
  <span class="kw">return</span> isFinal();
}</code></pre></div>
<h4 id="regex-representation">RegEx Representation</h4>
<p>The various RegEx operations are represented as derived classes (roughly following the composite design pattern).</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> RE {};

<span class="kw">class</span> Ch : <span class="kw">public</span> RE {
 <span class="kw">private</span>:
  <span class="dt">char</span> c;
  <span class="kw">public</span>:
  Ch (<span class="dt">char</span> _c) { c = _c; }
};

<span class="kw">class</span> Alt : <span class="kw">public</span> RE {
 <span class="kw">private</span>:
  RE* r1; <span class="co">// Recall that if we want to use virtual methods in C++,</span>
  RE* r2; <span class="co">// they must operate on a dynamic (heap-allocated) object.</span>
 <span class="kw">public</span>:
  Alt (RE* _r1, RE* _r2) { r1 = _r1; r2 = _r2; }  
};
<span class="co">// and so on  </span></code></pre></div>
<h4 id="thompson-transformation">Thompson Transformation</h4>
<p>How to implement the (Thompson) transformation from <code>RE</code> to <code>NFA</code>? As the transformation largely observes the various RegEx pattern constructs, there are three possible approaches in an OO language:</p>
<ul>
<li><p>Introduce some virtual method in <code>RE</code> which then will be specialized for the derived classes.</p></li>
<li><p>Apply the visitor design pattern.</p></li>
<li><p>Apply some dynamic type dispatch (see instanceOf in Java), here's a sketch in C++ (details are missing!)</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">NFA transformWorker(RE *r) {

  vector&lt;Transition&gt; ts;
  <span class="dt">int</span> start, stop;

  <span class="kw">switch</span>(r-&gt;ofType()) {

  <span class="kw">case</span> AltType: {
     Alt* r2 = (Alt*) r;

     <span class="co">// 1. Build NFA for left and right operand</span>
     NFA n1 = transformWorker(r2-&gt;getLeft());
     NFA n2 = transformWorker(r2-&gt;getRight());

     <span class="co">// 2. Build new initial and final state.</span>
     start = fresh();
     stop = fresh();
     <span class="dt">int</span> n1_start = n1.getInitial();
     <span class="dt">int</span> n1_stop  = n1.getFinals()[<span class="dv">0</span>];
     <span class="dt">int</span> n2_start = n2.getInitial();
     <span class="dt">int</span> n2_stop  = n2.getFinals()[<span class="dv">0</span>];


     <span class="co">// 3. Build NFA for alternative.</span>
     vector&lt;Transition&gt; t1 = n1.getTransitions();
     vector&lt;Transition&gt; t2 = n2.getTransitions();

     ts.insert(ts.end(),t1.begin(),t1.end());
     ts.insert(ts.end(),t2.begin(),t2.end());
     ts.push_back(Transition(start, n1_start));
     ts.push_back(Transition(start, n2_start));
     ts.push_back(Transition(n1_stop, stop));
     ts.push_back(Transition(n2_stop, stop));

     <span class="kw">return</span> NFA(ts,start,stop);
  }
      


  } <span class="co">// switch</span>


} <span class="co">// transform</span></code></pre></div>
<h3 id="the-ocaml-functional-approach">The OCaml (functional) approach</h3>
<p>Functional languages are great at representation tree-like data structures and writing functions which operate on them. Here's a sketch how to implement the Thompson transformation in OCaml.</p>
<h3 id="fsa-representation-1">FSA Representation</h3>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> transition = <span class="dt">TransChar</span> <span class="kw">of</span> <span class="dt">int</span>*<span class="dt">char</span>*<span class="dt">int</span>
                | <span class="dt">TransEps</span> <span class="kw">of</span> <span class="dt">int</span>*<span class="dt">int</span>
                                    
<span class="kw">type</span> fsa = { start : <span class="dt">int</span>;
             final : <span class="dt">int</span> <span class="dt">list</span>;
             trans : transition <span class="dt">list</span> }</code></pre></div>
<p>Running the NFA.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> <span class="kw">rec</span> run nfa current ws = <span class="kw">match</span> ws <span class="kw">with</span>
  | [] -&gt; List<span class="kw">.</span>exists (<span class="kw">fun</span> x -&gt; List<span class="kw">.</span>mem x nfa.final) (closure nfa current)
  | (w::ws) -&gt; <span class="kw">let</span> clos = closure nfa current <span class="kw">in</span>
               <span class="kw">let</span> next = removeDuplicates
                                (List<span class="kw">.</span>concat (List<span class="kw">.</span>map (step nfa w) clos)) <span class="kw">in</span>
               run nfa next ws

<span class="kw">let</span> matcher nfa ws = run nfa [nfa.start] (toList ws)</code></pre></div>
<p>Aside. Like in C, a function must be declared first before being used. If there are mutual dependencies, you will need to combine them in a mutually defined <code>let</code> binding group.</p>
<p>Helper functions.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(* retrieve all states (avoiding duplicates),</span>
<span class="co">   assumes that each state is mentioned in some transition *)</span>             
<span class="kw">let</span> allStates fsa = removeDuplicates (
                    List<span class="kw">.</span>concat (
                          List<span class="kw">.</span>map (<span class="kw">fun</span> t -&gt; <span class="kw">match</span> t <span class="kw">with</span>
                                             | <span class="dt">TransChar</span> (s1,_,s2) -&gt; [s1; s2]
                                             | <span class="dt">TransEps</span> (s1,s2) -&gt; [s1; s2])
                          fsa.trans))


             
<span class="co">(* compute all transitions that can be reached via an epsilon transition *)</span>
<span class="kw">let</span> stepEpsilon nfa state =
       <span class="kw">let</span> <span class="kw">rec</span> go ts = <span class="kw">match</span> ts <span class="kw">with</span>
                         | [] -&gt; []                                       
                         | (<span class="dt">TransChar</span> _::ts) -&gt; go ts 
                         | (<span class="dt">TransEps</span> (s1,s2))::ts -&gt; <span class="kw">if</span> state == s1
                                                     <span class="kw">then</span> s2 :: go ts
                                                     <span class="kw">else</span> go ts        
       <span class="kw">in</span> go nfa.trans


<span class="co">(* build closure:</span>
<span class="co">   for each current state apply stepEpsilon</span>
<span class="co">   remove all duplicates</span>
<span class="co">   continue as long as new states are added *)</span>
<span class="kw">let</span> <span class="kw">rec</span> closure nfa current =
  <span class="kw">let</span> next = removeDuplicates (List<span class="kw">.</span>append
                                     current
                                     (List<span class="kw">.</span>concat (List<span class="kw">.</span>map (stepEpsilon nfa)
                                                             current))) <span class="kw">in</span>
  <span class="kw">if</span> List<span class="kw">.</span>length next == List<span class="kw">.</span>length current
     <span class="co">(* next == current will not work !!!*)</span>
  <span class="kw">then</span> current
  <span class="kw">else</span> closure nfa next

<span class="co">(* consume sym and move to next set of states *)</span>               
<span class="kw">let</span> step nfa sym state =
  List<span class="kw">.</span>fold_left (<span class="kw">fun</span> states -&gt;
                  <span class="kw">fun</span> t -&gt; <span class="kw">match</span> t <span class="kw">with</span>
                             | <span class="dt">TransEps</span> _ -&gt; states
                             | <span class="dt">TransChar</span> (s1,c,s2) -&gt; <span class="kw">if</span> s1 == state &amp;&amp; sym == c
                                                      <span class="kw">then</span> s2 :: states
                                                      <span class="kw">else</span> states)
                  [] nfa.trans</code></pre></div>
<h2 id="complete-ocaml-source-code">Complete OCaml Source Code</h2>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(* File thompson.ml *)</span>

<span class="co">(* Making use of http://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html *)</span>

                
<span class="co">(* Finite State Automata:</span>
<span class="co">     (1) Some initial state</span>
<span class="co">     (2) Set of final states</span>
<span class="co">     (3) Set of transitions,</span>
<span class="co">          either epsilon transition (spontaneous move from one state to the next, or</span>
<span class="co">          consumption of some input symbol                                                                                       </span>
<span class="co"> *)</span>

<span class="kw">type</span> transition = <span class="dt">TransChar</span> <span class="kw">of</span> <span class="dt">int</span>*<span class="dt">char</span>*<span class="dt">int</span>
                | <span class="dt">TransEps</span> <span class="kw">of</span> <span class="dt">int</span>*<span class="dt">int</span>
                                    
<span class="kw">type</span> fsa = { start : <span class="dt">int</span>;
             final : <span class="dt">int</span> <span class="dt">list</span>;
             trans : transition <span class="dt">list</span> }


<span class="co">(* removing duplicates *)</span>             
<span class="kw">let</span> uniq_cons x xs = <span class="kw">if</span> List<span class="kw">.</span>mem x xs <span class="kw">then</span> xs <span class="kw">else</span> x :: xs
<span class="kw">let</span> removeDuplicates xs = List<span class="kw">.</span>fold_right uniq_cons xs []             

<span class="co">(* retrieve all states (avoiding duplicates),</span>
<span class="co">   assumes that each state is mentioned in some transition *)</span>             
<span class="kw">let</span> allStates fsa = removeDuplicates (
                    List<span class="kw">.</span>concat (
                          List<span class="kw">.</span>map (<span class="kw">fun</span> t -&gt; <span class="kw">match</span> t <span class="kw">with</span>
                                             | <span class="dt">TransChar</span> (s1,_,s2) -&gt; [s1; s2]
                                             | <span class="dt">TransEps</span> (s1,s2) -&gt; [s1; s2])
                          fsa.trans))


             
<span class="co">(* compute all transitions that can be reached via an epsilon transition *)</span>
<span class="kw">let</span> stepEpsilon nfa state =
       <span class="kw">let</span> <span class="kw">rec</span> go ts = <span class="kw">match</span> ts <span class="kw">with</span>
                         | [] -&gt; []                                       
                         | (<span class="dt">TransChar</span> _::ts) -&gt; go ts 
                         | (<span class="dt">TransEps</span> (s1,s2))::ts -&gt; <span class="kw">if</span> state == s1
                                                     <span class="kw">then</span> s2 :: go ts
                                                     <span class="kw">else</span> go ts        
       <span class="kw">in</span> go nfa.trans

             
<span class="kw">let</span> <span class="kw">rec</span> print_list_of_int xs = <span class="kw">match</span> xs <span class="kw">with</span>
  | [] -&gt; print_string <span class="st">&quot;&quot;</span>
  | x::xs -&gt; print_string (string_of_int x);
             print_string <span class="st">&quot; &quot;</span>;
             print_list_of_int xs
             
<span class="co">(* build closure:</span>
<span class="co">   for each current state apply stepEpsilon</span>
<span class="co">   remove all duplicates</span>
<span class="co">   continue as long as new states are added *)</span>
<span class="kw">let</span> <span class="kw">rec</span> closure nfa current =
  <span class="kw">let</span> next = removeDuplicates (List<span class="kw">.</span>append
                                     current
                                     (List<span class="kw">.</span>concat (List<span class="kw">.</span>map (stepEpsilon nfa)
                                                             current))) <span class="kw">in</span>
  <span class="kw">if</span> List<span class="kw">.</span>length next == List<span class="kw">.</span>length current
     <span class="co">(* next == current will not work !!!*)</span>
  <span class="kw">then</span> current
  <span class="kw">else</span> closure nfa next

<span class="co">(* consume sym and move to next set of states *)</span>               
<span class="kw">let</span> step nfa sym state =
  List<span class="kw">.</span>fold_left (<span class="kw">fun</span> states -&gt;
                  <span class="kw">fun</span> t -&gt; <span class="kw">match</span> t <span class="kw">with</span>
                             | <span class="dt">TransEps</span> _ -&gt; states
                             | <span class="dt">TransChar</span> (s1,c,s2) -&gt; <span class="kw">if</span> s1 == state &amp;&amp; sym == c
                                                      <span class="kw">then</span> s2 :: states
                                                      <span class="kw">else</span> states)
                  [] nfa.trans


                  
<span class="kw">let</span> <span class="kw">rec</span> run nfa current ws = <span class="kw">match</span> ws <span class="kw">with</span>
  | [] -&gt; List<span class="kw">.</span>exists (<span class="kw">fun</span> x -&gt; List<span class="kw">.</span>mem x nfa.final) (closure nfa current)
  | (w::ws) -&gt; <span class="kw">let</span> clos = closure nfa current <span class="kw">in</span>
               <span class="kw">let</span> next = removeDuplicates
                                (List<span class="kw">.</span>concat (List<span class="kw">.</span>map (step nfa w) clos)) <span class="kw">in</span>
               run nfa next ws

<span class="co">(* Convert string to list of characters *)</span>                   
<span class="kw">let</span> <span class="kw">rec</span> toList ch = <span class="kw">match</span> ch <span class="kw">with</span>
    | <span class="st">&quot;&quot;</span> -&gt; []
    | ch -&gt; (String<span class="kw">.</span>get ch <span class="dv">0</span> ) :: (toList (String<span class="kw">.</span>sub ch <span class="dv">1</span> ( (String<span class="kw">.</span>length ch)<span class="dv">-1</span>) ) )
                                    
<span class="kw">let</span> matcher nfa ws = run nfa [nfa.start] (toList ws)


 <span class="kw">type</span> re =
  | <span class="dt">Epsilon</span>
  | <span class="dt">Phi</span>
  | <span class="dt">Letter</span> <span class="kw">of</span> <span class="dt">char</span>
  | <span class="dt">Seq</span> <span class="kw">of</span> re * re
  | <span class="dt">Alt</span> <span class="kw">of</span> re * re
  | <span class="dt">Star</span> <span class="kw">of</span> re


<span class="kw">let</span> nameSupply = <span class="dt">ref</span> <span class="dv">1</span>
<span class="kw">let</span> fresh _ =  nameSupply := !nameSupply + <span class="dv">1</span>;
               !nameSupply

<span class="co">(* apply thompson NFA transformation,</span>
<span class="co">   we obtain a NFA where the number of states and transitions</span>
<span class="co">   is linear in the size of the regex,</span>
<span class="co">   there is also exactly one final state</span>
<span class="co">*)</span>                
<span class="kw">let</span> <span class="kw">rec</span> thompson re = <span class="kw">match</span> re <span class="kw">with</span>
  | <span class="dt">Epsilon</span> -&gt; <span class="kw">let</span> s1 = fresh() <span class="kw">in</span>
               <span class="kw">let</span> s2 = fresh() <span class="kw">in</span>
               { start = s1;
                 final = [s2];
                 trans = [<span class="dt">TransEps</span> (s1,s2)] }

                 
  | <span class="dt">Phi</span> -&gt; <span class="kw">let</span> s1 = fresh() <span class="kw">in</span>
           <span class="kw">let</span> s2 = fresh() <span class="kw">in</span>                
           { start = s1;
             final = [s2];
             trans = [] }

  | <span class="dt">Letter</span> sym -&gt; <span class="kw">let</span> s1 = fresh() <span class="kw">in</span>
                  <span class="kw">let</span> s2 = fresh() <span class="kw">in</span>                
                  { start = s1;
                    final = [s2];
                    trans = [<span class="dt">TransChar</span> (s1,sym,s2)] }          
  | <span class="dt">Seq</span> (r,s) -&gt; <span class="kw">let</span> nfa1 = thompson r <span class="kw">in</span>
                 <span class="kw">let</span> nfa2 = thompson s <span class="kw">in</span>
                 <span class="kw">let</span> s1 = fresh() <span class="kw">in</span>
                 <span class="kw">let</span> s2 = fresh() <span class="kw">in</span>
                 { start = s1;
                   final = [s2];
                   trans = <span class="dt">TransEps</span> (s1,nfa1.start) ::
                           <span class="dt">TransEps</span> (List<span class="kw">.</span>hd nfa1.final,nfa2.start) ::
                           <span class="dt">TransEps</span> (List<span class="kw">.</span>hd nfa2.final, s2) ::
                             (List<span class="kw">.</span>append nfa1.trans nfa2.trans) }
  | <span class="dt">Alt</span> (r,s) -&gt; <span class="kw">let</span> nfa1 = thompson r <span class="kw">in</span>
                 <span class="kw">let</span> nfa2 = thompson s <span class="kw">in</span>
                 <span class="kw">let</span> s1 = fresh() <span class="kw">in</span>
                 <span class="kw">let</span> s2 = fresh() <span class="kw">in</span>
                 { start = s1;
                   final = [s2];
                   trans = <span class="dt">TransEps</span> (s1,nfa1.start) ::
                           <span class="dt">TransEps</span> (s1,nfa2.start) ::  
                           <span class="dt">TransEps</span> (List<span class="kw">.</span>hd nfa1.final, s2) ::
                           <span class="dt">TransEps</span> (List<span class="kw">.</span>hd nfa2.final, s2) ::
                             (List<span class="kw">.</span>append nfa1.trans nfa2.trans) }
  | <span class="dt">Star</span> r -&gt; <span class="kw">let</span> nfa = thompson r <span class="kw">in</span>
              <span class="kw">let</span> s1 = fresh() <span class="kw">in</span>
              <span class="kw">let</span> s2 = fresh() <span class="kw">in</span>
              { start = s1;
                final = [s2];
                trans = <span class="dt">TransEps</span> (s1,nfa.start) ::
                        <span class="dt">TransEps</span> (List<span class="kw">.</span>hd nfa.final, s2) ::
                        <span class="dt">TransEps</span> (s1,s2) ::
                        <span class="dt">TransEps</span> (s2,s1) ::
                        nfa.trans }    


<span class="co">(* https://en.wikipedia.org/wiki/DOT_(graph_description_language) </span>

<span class="co">how to use:</span>

<span class="co"> printDotToFile &quot;MY.dot&quot; (thompson YOUR_REGEX)</span>


<span class="co"> then on the command line:</span>

<span class="co"> dot -v -Teps -oMY.eps MY.dot</span>

<span class="co">*)</span>
<span class="kw">let</span> toDot fsa =
  <span class="kw">let</span>  nonFinal = List<span class="kw">.</span>filter
                      (<span class="kw">fun</span> s -&gt; not (List<span class="kw">.</span>mem s (fsa.final))) (allStates fsa) <span class="kw">in</span>
  (String<span class="kw">.</span>concat <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> 
               [ <span class="st">&quot;digraph G {&quot;</span> ;
                <span class="st">&quot;rankdir = LR;&quot;</span> ;
                <span class="st">&quot; 0 -&gt; &quot;</span> ^ string_of_int (fsa.start)
  ])
  ^  
  <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>  
  ^
  (String<span class="kw">.</span>concat <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
   (List<span class="kw">.</span>map (<span class="kw">fun</span> s -&gt; string_of_int s ^ <span class="st">&quot;[shape = doublecircle];&quot;</span>)
             fsa.final))


  ^
  <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>  
  ^    
  (String<span class="kw">.</span>concat <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
         (List<span class="kw">.</span>map (<span class="kw">fun</span> s -&gt; string_of_int s ^ <span class="st">&quot;[shape = circle];&quot;</span>)
                   nonFinal))

  ^
  <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>  
  ^    
  (String<span class="kw">.</span>concat <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
    (List<span class="kw">.</span>map
      (<span class="kw">fun</span> t -&gt; <span class="kw">match</span> t <span class="kw">with</span>
                | <span class="dt">TransChar</span> (s1,c,s2) -&gt;
                     (string_of_int s1) ^ <span class="st">&quot; -&gt; &quot;</span> ^ (string_of_int s2) ^
                     <span class="st">&quot;[label = &quot;</span> ^ (String<span class="kw">.</span>make <span class="dv">1</span> c) ^ <span class="st">&quot;];&quot;</span>
                | <span class="dt">TransEps</span> (s1,s2) -&gt;
                      (string_of_int s1) ^ <span class="st">&quot; -&gt; &quot;</span> ^ (string_of_int s2) ^ <span class="st">&quot;;&quot;</span>)
      fsa.trans))

  ^
 <span class="st">&quot;</span><span class="ch">\n</span><span class="st"> }&quot;</span>

<span class="co">(* few examples *)</span>


<span class="kw">let</span> printDotToFile fileName fsa = output_string (open_out fileName) (toDot fsa)
                                            
<span class="kw">let</span> exR1 = <span class="dt">Letter</span> <span class="ch">&#39;a&#39;</span>
<span class="kw">let</span> exR2 = <span class="dt">Alt</span> (<span class="dt">Letter</span> <span class="ch">&#39;a&#39;</span>, <span class="dt">Letter</span> <span class="ch">&#39;b&#39;</span>)
<span class="kw">let</span> exR3 = <span class="dt">Seq</span> (<span class="dt">Letter</span> <span class="ch">&#39;a&#39;</span>, <span class="dt">Letter</span> <span class="ch">&#39;b&#39;</span>)
<span class="kw">let</span> exR4 = <span class="dt">Star</span> exR2
<span class="kw">let</span> exR5 = <span class="dt">Star</span> exR3
<span class="kw">let</span> exR6 = <span class="dt">Star</span> exR4                
                
<span class="kw">let</span> th1 = thompson exR4                   </code></pre></div>
</div>
<div id="brzozowskis-dfa-construction" class="slide section level1">
<h1>Brzozowski's DFA Construction</h1>
<p>We will take a look at another approach of how to transform a RegEx into some FSA. This time we build a DFA (= deterministic finite automata).</p>
<p>We apply a symbolic method where regular expressions themselves are treated like states. The method is due to Brzozowski. For a brief overview check <a href="https://en.wikipedia.org/wiki/Brzozowski_derivative">here</a>.</p>
<h2 id="highlights">Highlights</h2>
<p>Given some expression r and a symbol x, we obtain the <em>derivative</em> of r w.r.t. x, written d(r,x), by taking way the leading symbol x from r.</p>
<p>In semantic terms, d(r,x) can be described as follows:</p>
<pre><code>L(d(r,x)) = x \ L(r)</code></pre>
<ul>
<li><p>x  L(r) denotes the left quotient, i.e. the language <code>{ w | x . w in L(r)}</code>.</p>
<ul>
<li>We write <code>.</code> to denote concatenation. In some exposition this is left silent, i.e. <code>x w</code>.</li>
</ul></li>
<li><p>Hence, the derivative <code>d(r,x)</code> denotes the set of all words from L(R) where the leading symbol x has been removed.</p></li>
</ul>
<p>Thus, it is easy to solve the word problem. Let <code>w</code> be a word consisting of symbols <code>x1 . x2 .... xn-1 . xn</code>.</p>
<p>Compute</p>
<pre><code>d(r,x1) = r1
d(r1,x2) = r2
...
d(rn-1,xn) = rn</code></pre>
<p>That is, we repeatedly build the derivative of r w.r.t symbols xi.</p>
<p>Check if the final expression <code>rn</code> is nullable. An expression s is <em>nullable</em> if epsilon in L(s).</p>
<p>The derivative operation <code>d(r,x)</code> as well as the nullability test <code>n(r)</code> can be computed by some simple recursion over the structure of our RegEx language.</p>
<pre><code>r,s ::= a | b | c | ...         Symbols aka letters taken from a finite alphabet
    |  epsilon                  Empty word
    |  phi                      Empty language
    |  r + r                    Alternatives
    |  r . r                    Sequence aka concatenation
    |  r*                       Kleene star

u,v,w ::= epsilon               empty word
      |  w . w                  concatenation</code></pre>
<h2 id="nullability">Nullability</h2>
<p>How to check that an expression is <em>nullable</em>, i.e. it's language denotation contains the empty string?</p>
<p>We simply observe the various RegEx pattern constructs. We write <code>n(r)</code> to denote the nullability test which yields a Boolean value (true/false).</p>
<pre><code>n(x) where xi is a symbol never holds.

n(epsilon) always holds.

n(phi) never holds.

n(r + s) holds iff n(r) holds or n(s) holds.

n(r . s) holds iff n(r) holds and n(s) holds.

n(r*) always holds.</code></pre>
<h2 id="derivatives">Derivatives</h2>
<p>We write <code>d(r,x)</code> to denote the derivative obtained by extracting the leading symbol <code>x</code> from expression <code>r</code>. For each derivative, we wish that the following holds: <code>L(d(r,x)) = x \ L(r)</code>.</p>
<p>As in case of the nullability test, the derivative operation is defined by observing the structure of regular expression patterns. Instead of a Boolean value, we yield another expression (the derivative).</p>
<pre><code>d(x,y) =   either epsilon if x == y or phi otherwise

d(epsilon,y) = phi

d(phi,y)     = phi

d(r + s, y)  = d(r,y) + d(s,y)

d(r . s, y)  =  if n(r)
                then d(r,y) . s +  d(s,y)
                else d(r,y) . s

d(r*, y)     = d(r,y) . r*</code></pre>
<p>Some examples.</p>
<p>Let's build the derivative of some expressions.</p>
<pre><code>d((x . y)*, x) = d(x . y, x) . (x . y)*
               = d(x,x) . y . (x . y)*
               = epsilon . y . (x . y)*


d(x* . x, x) = d(x*, x) . x + d(x,x)
             = d(x,x) . x* . x + epsilon
             = epsilon . x* . x + epsilon

d(x*, x) = d(x,x) . x*
         = epsilon . x*</code></pre>
<p>Shorthand: We write <code>r --x--&gt; s</code> for <code>s = d(r,x)</code>.</p>
<pre><code>       x*
--x--&gt; d(x,x) . x*
       = epsilon . x*
--x--&gt; d(epsilon . x*, x)
       = d(epsilon,x) . x* + d(x*,x)
       = phi . x* + epsilon . x*
--x--&gt; d(phi . x* + epsilon . x*, x)
       = d(phi . x*, x) + d(epsilon . x*, x)
       = phi . x* + phi . x* + epsilon . x*</code></pre>
<p>Observation:</p>
<ul>
<li><p>If we repeatedly build the derivative, the size of the resulting terms is growing.</p></li>
<li><p>Semantically, all terms are equal to <code>x*</code>.</p></li>
</ul>
<h2 id="simplifications">Simplifications</h2>
<p>Checking for semantic equivalence is costly (to reduce the size of derivatives).</p>
<p>Brzozowski observed that few (syntactic) simplification rules are sufficient to ensure that the size of derivatives will not grow.</p>
<pre><code>(Idempotence)  r + r = r

(Associativity) (r + s) + t = r + (s + t)

(Commutativity) r + s = s + r</code></pre>
<p>The (Idempotence) rule says in case of syntactically equal elements in an alternative, we can drop one of the elements.</p>
<p>The (Associativity) and (Commutativity) rule are for convenience so that we can move (syntactically) equal elements next to each other.</p>
<p>For example, consider</p>
<pre><code>           (r + s) + r
=_Comm     r + (r + s)
=_Assoc    (r + r) + s
=_Idemp    r + s</code></pre>
<p>Your first project task is to implement the derivative and simplification procedure for derivatives in terms of OCaml. To help those more familiar with OO, below is a brief sketch in some pseudo OO language.</p>
<h2 id="sketch-of-oo-implementation">Sketch of OO implementation</h2>
<p>Here's a sketch of an OO-based implementation making use of inheritance and virtual methods.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">abstract</span> <span class="kw">class</span> RE {
   <span class="fu">n</span>() <span class="dt">boolean</span>;
   <span class="fu">d</span>(<span class="dt">char</span>) RE;
}

<span class="kw">class</span> Phi : RE {
    <span class="fu">Phi</span>() {}
    <span class="fu">n</span>() { <span class="kw">return</span> <span class="kw">false</span>; }
    <span class="fu">d</span>(<span class="dt">char</span> x) { <span class="kw">return</span> <span class="fu">Phi</span>(); }
}    

<span class="kw">class</span> Eps : RE {
    <span class="fu">Eps</span>() {}
    <span class="fu">n</span>() { <span class="kw">return</span> <span class="kw">true</span>; }
    <span class="fu">d</span>(<span class="dt">char</span> x) { <span class="kw">return</span> <span class="fu">Phi</span>(); }
}    

<span class="kw">class</span> Alt : RE {
    RE left, right;
    <span class="fu">Alt</span> (RE x, RE y) { left = x; right = y; }
    <span class="fu">n</span>() { <span class="kw">return</span> left.<span class="fu">n</span>() || right.<span class="fu">n</span>(); }
    <span class="fu">d</span>(<span class="dt">char</span> x) { <span class="kw">return</span> <span class="fu">Alt</span>(left.<span class="fu">d</span>(x), right.<span class="fu">d</span>(x)); }
}

<span class="kw">class</span> Seq : RE {
    RE left, right;
    <span class="fu">Seq</span> (RE x, RE y) { left = x; right = y; }
    <span class="fu">n</span>() { <span class="kw">return</span> left.<span class="fu">n</span>() &amp;&amp; right.<span class="fu">n</span>(); }
    <span class="fu">d</span>(<span class="dt">char</span> x) {
        <span class="kw">if</span> (left.<span class="fu">n</span>()) {
           <span class="kw">return</span> <span class="fu">Alt</span>(<span class="fu">Seq</span> (left.<span class="fu">d</span>(x), right), right.<span class="fu">d</span>(x));
        } <span class="kw">else</span> {
       <span class="kw">return</span> <span class="fu">Seq</span> (left.<span class="fu">d</span>(x), right);
    }
    }   
}</code></pre></div>
<h2 id="ocaml-implementation">OCaml implementation</h2>
<p>See Project 1.</p>
</div>
<div id="disambiguation" class="slide section level1">
<h1>Disambiguation</h1>
<p>Consider the expression</p>
<pre><code>(a+b)* + a.b.a</code></pre>
<p>The expression is ambiguous in the sense that the input string <code>a.b.a</code> matches the left as well as the right component.</p>
<p>Checking if a regular expression is ambiguous is decidable. However, often we cannot avoid ambiguities.</p>
<p>For example, consider regular expressions to specify the valid set of identifiers as well as some key words such as</p>
<pre><code>[&#39;a&#39;-&#39;z&#39;]+ | &quot;while&quot; | &quot;for&quot;</code></pre>
<p>Aside: Change in syntax. I'm using some concrete source syntax where I write <code>|</code> for alternatives and <code>+</code> for one or more repetitions. <code>['a'-'z']</code> is referred to as a character class and is a shorthand for <code>'a'|...|'z'</code>.</p>
<p>There are several disambiguation strategies (to decide which match shall be chosen in case there are several possibilities). Two popular disambiguation strategies are Greedy and POSIX. There are some subtle differences between both. We will assume Greedy which selects the &quot;earliest left-most match&quot; (whereas POSIX selects the &quot;longest left-most match&quot;). You will find more (formal) details here: <a href="http://www.home.hs-karlsruhe.de/~suma0002/publications/DerivativesDiagnosisRegExAmbiguity.pdf">Derivative-Based Diagnosis of Regular Expression Ambiguity</a></p>
</div>
<div id="submatching-versus-parsing" class="slide section level1">
<h1>(Sub)Matching versus Parsing</h1>
<p>As can be seen from the above example, we are not only interested to know if a regular expression matches a string but wish to know which subparts of the expression match which substring.</p>
<p><em>Submatching</em> refers to process of relating subexpressions to the substrings they match. To refer to submatches, we annotate expressions with submatch annotations (we roughly follow the syntax of the OCaml lexer tool to be used later).</p>
<pre><code>&quot;while&quot; as x1 | &quot;for&quot; as x2 | [&#39;a&#39;-&#39;z&#39;]+ as x3</code></pre>
<p>In case of Kleene star there may be several (repeated) matches. For efficiency reasons, only the last match is kept.</p>
<p>A subexpression does not need to be annotated which means that we not interested in that match and that match shall be ignored. For example, in case of lexical analysis we ignore white space etc.</p>
<p><em>Parsing</em> obtains information about which subexpression match which substrings (like in case of submatching) but generally produces an abstract syntax tree representation from which all submatch information can be derived.</p>
<p>The abstract syntax tree (AST) can be viewed as a &quot;proof&quot; that a expression matches a string.</p>
<p>For our regular expression language</p>
<pre><code>r,s ::= a | b | c | ...         Symbols aka letters taken from a finite alphabet
    |  epsilon                  Empty word
    |  phi                      Empty language
    |  r + r                    Alternatives
    |  r . r                    Sequence aka concatenation
    |  r*                       Kleene star</code></pre>
<p>we use the following AST representation</p>
<pre><code>u,v ::= epsilon | x | L u | R u | (u,u) | [u1,...,un]

L stands for Left
R stands for Right</code></pre>
<p>Example:</p>
<pre><code>Expression:  (a + (b + a.b))*

Input: a.b

Parse trees/ASTs:

[L a, L (R b)]

[R (R (a,b))]</code></pre>
<p>How to obtain a AST for a given regular expression and input word?</p>
<p>Let's ask a different question. How to decide that a AST is valid for a regular expression?</p>
<h2 id="parsing---proofs-are-programs---curry-howard-isomorphism">Parsing - Proofs are Programs - Curry-Howard Isomorphism</h2>
<p>The membership tests provides us with a yes/no answer (if an expression matches/not matches a word). We wish to obtain more details why/how the match took place. In a first step, we consider a more operational representation of L(r). We introduce judgments <code>|- w in L(r)</code> to represent that w is a word in the language denoted by r. We use a natural deduction style proof system to deduce all valid judgments.</p>
<pre><code>(Eps) |- epsilon : L(epsilon)


(Sym) |- x : L(x)

          |- w : L(r)
(Alt-L)  -------------------
          |- w : L(r + s)

          |- w : L(s)
(Alt-R)  -------------------
          |- w : L(r + s)

          w = w1 . w2 for some w1 and w2
          |- w1 : L(r)
          |- w2 : L(s)
(Conc)  -----------------------
          |- w : L(r . s)

(Star-0) |- epsilon : L(r*)

          w = w1 . w2 for some w1 and w2
          |- w1 : L(r)
          |- w2 : L(r*)
(Star-N) --------------------
          |- w : L(r*)</code></pre>
<p>Here is an example derivation for <code>|- x.y : L((x+y)*)</code>.</p>
<pre><code>                             (Sym)    |- y : L(y) 
                             (Alt-R)  ----------------
    (Sym)   |- x : L(x)               |- y : L(x+y)   (Eps) |- epsilon : L((x+y)*)
    (Alt-L) --------------   (Star-N) --------------------------------------------
            |- x : L(x+y)             |- y : L((x+y)*)
(Star-N)   --------------------------------------------
            |- x.y : L((x+y)*)</code></pre>
<p>The derivation is written as a (upside down) tree.</p>
<ul>
<li><p>The root note is to be proven statement <code>|- x.y : L((x+y)*)</code></p></li>
<li><p>Leave nodes represent axioms (proof rules without any premise).</p></li>
<li><p>Intermediate nodes represent application of proof rules.</p></li>
</ul>
<p>We seek for a compact representation of this derivation tree.</p>
<p>Idea:</p>
<ul>
<li><p>Attach proof terms to the above proof rules.</p></li>
<li><p>Proof terms are a compact representation of derivation trees</p></li>
</ul>
<p>This is a well-known idea referred to as the &quot;proofs are programs principle&quot; and is due to Curry and Howard. Hence, this idea is also known as the Curry-Howard isomorphism. In case of context-free grammars (CFG), this is know as parsing where a parse tree effectively represents a compact proof of the derivation.</p>
<p>Proof terms are as follows.</p>
<pre><code> u,v ::= epsilon | x | L u | R u | (u,u) | [u1,...,un]

We use OCaml notation for lists.

us ::= [] | u :: us

[u1,u2] is a shorthand for u1 : (u2 :: [])</code></pre>
<p>We attach proof terms u to judgments <code>|- w : L(r)</code>. As we will shortly see, word w is redundant. Hence, we make use of judgments of the form <code>|- u : r</code>.</p>
<pre><code>(Eps) |- epsilon : epsilon


(Sym) |- x : x

          |- u : r
(Alt-L)  -------------------
          |- L u : r + s

          |- u : s
(Alt-R)  -------------------
          |- R u : r + s

          |- u1 : r
          |- u2 : s
(Conc)  -----------------------
          |- (u1,u2) : r . s

(Star-0) |- [] : r*

          |- u : r
          |- us : r*
(Star-N) --------------------
          |- u::us : r*</code></pre>
<p>Each proof term implies a word which we obtain by flattening the proof term.</p>
<pre><code>|epsilon| = epsilon

|x| = x

|L u| = |u|

|R u| = |u|

|(u,v)| = |u| . |v|

|[]| = epsilon

|u :: us| = |u| . |us|</code></pre>
<pre><code>Property: w in L(r) iff |- u : r where |u| = w</code></pre>
<p>TODO: Show construction of proof terms based on derivatives.</p>
</div>
<div id="extended-regular-expressions" class="slide section level1">
<h1>Extended Regular Expressions</h1>
<p>As discussed earlier, certain extensions can be expressed in terms of existing language constructs. Others such as negation are more involved.</p>
<p>Aside: The language of regular expressions is closed under negation (complement). But the process to obtain the expression representing the complement of another expression is rather involved.</p>
<p>How to adapt the Thomspon NFA and Brzozowski DFA method to include negation (complement)?</p>
</div>
<div id="lexical-analysis" class="slide section level1">
<h1>Lexical Analysis</h1>
<p>Goal:</p>
<ul>
<li><p>Identify the <em>atomic</em> units of a programming language we are interested in by grouping characters into tokens.</p></li>
<li><p>The (later) syntax analysis phase will then check if tokens form a valid phrase (i.e. the program is syntactically valid).</p></li>
</ul>
<p>Hence, this process is also referred to as <em>tokenization</em>. It's done more for convenience to break the syntax analysis part into more manageable pieces.</p>
<h2 id="terminology">Terminology</h2>
<p><em>Pattern</em>: Regular expression to describe patterns of input we are interested in.</p>
<p><em>Lexeme</em>: String (word) that matches a pattern.</p>
<p><em>Token</em>: Output of lexical analysis. Instead of reporting the lexeme we typically generate a more compact representation. Token may have attributes (can be the underlying lexeme or some other value).</p>
<h2 id="example">Example</h2>
<p>We use OCamllex syntax.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">| [<span class="ch">&#39;a&#39;</span>-<span class="ch">&#39;z&#39;</span>] <span class="kw">as</span> lxm { <span class="dt">LETTER</span> lxm }

<span class="dt">Pattern</span>: [<span class="ch">&#39;a&#39;</span>-<span class="ch">&#39;z&#39;</span>] which is shorthand <span class="kw">for</span> the alternative among all lowercase letters

<span class="dt">Lexeme</span>: character <span class="ch">&#39;b&#39;</span> <span class="kw">for</span> example

<span class="dt">Token</span>: <span class="dt">LETTER</span> <span class="ch">&#39;b&#39;</span></code></pre></div>
<p>Here are excerpts of the lexer rules for the regular expression language discussed in project 1.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">        rule token = parse
            [<span class="ch">&#39;\n&#39;</span> ]        { <span class="dt">EOL</span> }
          | [<span class="ch">&#39;a&#39;</span>-<span class="ch">&#39;z&#39;</span>] <span class="kw">as</span> lxm { <span class="dt">LETTER</span> lxm }
          | <span class="ch">&#39;+&#39;</span>            { <span class="dt">PLUS</span> }
          | <span class="ch">&#39;*&#39;</span>            { <span class="dt">STAR</span> }
          | <span class="ch">&#39;(&#39;</span>            { <span class="dt">LPAREN</span> }
          | <span class="ch">&#39;)&#39;</span>            { <span class="dt">RPAREN</span> }</code></pre></div>
<p>The input string</p>
<pre><code>(ab*)+c</code></pre>
<p>is turned into the sequence of tokens</p>
<pre><code>LPAREN (LETTER &#39;a&#39;) (LETTER &#39;b&#39;) STAR RPAREN PLUS (LETTER &#39;c&#39;)</code></pre>
<p>You can use a lexical analysis tool (such as OCamllex) on its own. In general, there is a tight integration between lexical analysis and syntax analysis as the syntax analysis part will operate on the sequence of tokens instead of the plain sequence of characters as found in the source program.</p>
</div>
<div id="summary" class="slide section level1">
<h1>Summary</h1>
<ul>
<li><p>Syntax matters.</p></li>
<li><p>Compiler (Thompson NFA) versus Interpreter (Brzozowski derivatives).</p>
<ul>
<li><p>Can build set of dissimilar derivatives beforehand (=&gt; compiler).</p></li>
<li><p>Can also build on-the-fly (=&gt; just-in time compiler).</p></li>
</ul></li>
<li><p>We will use regular expressions for lexical analysis.</p></li>
</ul>
</div>
</body>
</html>
